AS65 Assembler for R6502 [1.40].  Copyright 1994-2005, Frank A. Kingswood                                                Page    1
---------------------------------------------------------- 65C02_~1.A65 ----------------------------------------------------------

2882 lines read, no errors in pass 1.
                        ;
                        ; 6 5 C 0 2   E X T E N D E D   O P C O D E S   T E S T
                        ;
                        ; Copyright (C) 2013-2017  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all additional 65C02 opcodes, addressing
                        ; modes and functionality not available in the NMOS version of the 6502.
                        ; The 6502_functional_test is a prerequisite to this test.
                        ; NMI, IRQ, STP & WAI are covered in the 6502_interrupt_test.
                        ; 
                        ; version 04-dec-2017
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 from http://www.kingswood-consulting.co.uk/assemblers/
                        ; command line switches: -l -m -s2 -w -x -h0
                        ;                         |  |  |   |  |  no page headers in listing
                        ;                         |  |  |   |  65C02 extensions
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original 65C02 only!
                        ; Decimal ops will only be tested with valid BCD operands and the V flag will
                        ; be ignored as it is absolutely useless in decimal mode.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   19-jul-2013  1st version distributed for testing
                        ;   23-jul-2013  fixed BRA out of range due to larger trap macros
                        ;                added RAM integrity check
                        ;   16-aug-2013  added error report to standard output option
                        ;   23-aug-2015  change revoked
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;   28-aug-2015  fixed decimal adc/sbc immediate only testing carry
                        ;   09-feb-2017  fixed RMB/SMB tested when they shouldn't be tested
                        ;   04-dec-2017  fixed BRK not tested for actually going through the IRQ vector
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        ;                added skip override to undefined opcode as NOP test
                        
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended.
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $4e (78) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
000a =                  zero_page = $a  
                        
                        ;data_segment memory start address, $63 (99) consecutive Bytes required
                        ; + 12 Bytes at data_segment + $f9 (JMP indirect page cross test)
0200 =                  data_segment = $200
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 10kB of consecutive space required
                        ;                                   add 1 kB if I_flag = 2
0400 =                  code_segment = $400  
                        
                        ;added WDC only opcodes WAI & STP (0=test as NOPs, >0=no test)
0001 =                  wdc_op = 1
                        
                        ;added Rockwell & WDC opcodes BBR, BBS, RMB & SMB
                        ;(0=test as NOPs, 1=full test, >1=no test) 
0002 =                  rkwl_wdc_op = 2
                        
                        ;skip testing all undefined opcodes override
                        ;0=test as NOP, >0=skip
0001 =                  skip_nop = 1
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                                noopt       ;do not take shortcuts
                                
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_as      macro       ;testing result in accu & flags, save accu
                                    pha
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    pla
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                    ldx #11         ;reset modifiable RAM
                        ccs1\?      sta jxi_tab,x   ;JMP indirect page cross area
                                    dex
                                    bpl ccs1\?
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                                    
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
000a =                          org zero_page
                        ;break test interrupt save
000a : 00               irq_a   ds  1               ;a register
000b : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
000c :                  zpt                         ;5 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
000c : 00               adfc    ds  1               ;carry flag before op
000d : 00               ad1     ds  1               ;operand 1 - accumulator
000e : 00               ad2     ds  1               ;operand 2 - memory / immediate
000f : 00               adrl    ds  1               ;expected result bits 0-7
0010 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0011 : 00               adrf    ds  1               ;expected flags NV0000ZC (-V in decimal mode)
0012 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0013 :                  zp_bss
0013 : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0017 : 7f               zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
0018 : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
001c : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0020 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
0024 : 1002             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
0026 : 1102                     dw  abs1+1
0028 : 1202                     dw  abs1+2
002a : 1302                     dw  abs1+3
002c : 1402                     dw  abs7f
002e : 1801             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0030 : 0502             indt    dw  abst            ;indirect pointer to store area in absolute memory
0032 : 0602                     dw  abst+1
0034 : 0702                     dw  abst+2
0036 : 0802                     dw  abst+3
0038 : 0d01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
003a : 4702             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
003c : 4802                     dw  absAN+1
003e : 4902                     dw  absAN+2
0040 : 4a02                     dw  absAN+3
0042 : 4b02             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
0044 : 4c02                     dw  absEO+1
0046 : 4d02                     dw  absEO+2
0048 : 4e02                     dw  absEO+3
004a : 4302             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
004c : 4402                     dw  absOR+1
004e : 4502                     dw  absOR+2
0050 : 4602                     dw  absOR+3
                        ;add/subtract indirect pointers
0052 : 0502             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
0054 : 0602             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
0056 : 0601             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
0058 : 0701             sbiy2   dw  sba2-$ff
005a :                  zp_bss_end
                            
0200 =                          org data_segment
0200 : 0000             pg_x    ds  2               ;high JMP indirect address for page cross bug
0202 : 00               test_case   ds  1           ;current test number
0203 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0205 :                  abst                        ;5 bytes store/modify test area
0205 : 00               ada2    ds  1               ;operand 2
0206 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0207 : 000000                   ds  3               ;fill remaining bytes
020a :                  data_bss
                            if load_data_direct = 1
020a : 6900             ex_adci adc #0              ;execute immediate opcodes
020c : 60                       rts
020d : e900             ex_sbci sbc #0              ;execute immediate opcodes
020f : 60                       rts
                            else
                        ex_adci ds  3
                        ex_sbci ds  3
                            endif
0210 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0214 : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
0215 : 80800002         fLDx    db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
0219 :                  rASL                        ;expected result ASL & ROL -carry  
0219 : 86048200         rROL    db  $86,$04,$82,0   ; "
021d : 87058301         rROLc   db  $87,$05,$83,1   ;expected result ROL +carry
0221 :                  rLSR                        ;expected result LSR & ROR -carry
0221 : 61412000         rROR    db  $61,$41,$20,0   ; "
0225 : e1c1a080         rRORc   db  $e1,$c1,$a0,$80 ;expected result ROR +carry
0229 :                  fASL                        ;expected flags for shifts
0229 : 81018002         fROL    db  fnc,fc,fn,fz    ;no carry in
022d : 81018000         fROLc   db  fnc,fc,fn,0     ;carry in
0231 :                  fLSR
0231 : 01000102         fROR    db  fc,0,fc,fz      ;no carry in
0235 : 81808180         fRORc   db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
0239 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
023e : 0080800200       fINC    db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
0243 : 001f7180         absOR   db  0,$1f,$71,$80   ;test pattern for OR
0247 : 0fff7f80         absAN   db  $0f,$ff,$7f,$80 ;test pattern for AND
024b : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
024f : 00f11f00         absORa  db  0,$f1,$1f,0     ;test pattern for OR
0253 : f0ffffff         absANa  db  $f0,$ff,$ff,$ff ;test pattern for AND
0257 : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
025b : 00ff7f80         absrlo  db  0,$ff,$7f,$80
025f : 02800080         absflo  db  fz,fn,0,fn
0263 :                  data_bss_end
                        ;define area for page crossing JMP (abs) & JMP (abs,x) test
02f9 =                  jxi_tab equ data_segment + $100 - 7     ;JMP (jxi_tab,x) x=6
02fd =                  ji_tab  equ data_segment + $100 - 3     ;JMP (ji_tab+2)
0300 =                  jxp_tab equ data_segment + $100         ;JMP (jxp_tab-255) x=255
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0202                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                                ldx #11         ;reset modifiable RAM
                        gcs1    sta jxi_tab,x   ;JMP indirect page cross area
                                dex
                                bpl gcs1
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
0409 : ad0202          >            lda test_case   ;previous test
040c : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
040e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
0410 : a901            >            lda #test_num   ;*** next tests' number
0412 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing stack operations PHX PHY PLX PLY
0415 : a999                     lda #$99        ;protect a
0417 : a2ff                     ldx #$ff        ;initialize stack
0419 : 9a                       txs
041a : a255                     ldx #$55
041c : da                       phx
041d : a2aa                     ldx #$aa
041f : da                       phx
0420 : ecfe01                   cpx $1fe        ;on stack ?
                                trap_ne
0423 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0425 : ba                       tsx
0426 : e0fd                     cpx #$fd        ;sp decremented?
                                trap_ne
0428 : d0fe            >        bne *           ;failed not equal (non zero)
                        
042a : 7a                       ply
042b : c0aa                     cpy #$aa        ;successful retreived from stack?
                                trap_ne
042d : d0fe            >        bne *           ;failed not equal (non zero)
                        
042f : 7a                       ply
0430 : c055                     cpy #$55
                                trap_ne
0432 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0434 : ccff01                   cpy $1ff        ;remains on stack?
                                trap_ne
0437 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0439 : ba                       tsx
043a : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
043c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
043e : a0a5                     ldy #$a5
0440 : 5a                       phy
0441 : a05a                     ldy #$5a
0443 : 5a                       phy
0444 : ccfe01                   cpy $1fe        ;on stack ?
                                trap_ne
0447 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0449 : ba                       tsx
044a : e0fd                     cpx #$fd        ;sp decremented?
                                trap_ne
044c : d0fe            >        bne *           ;failed not equal (non zero)
                        
044e : fa                       plx
044f : e05a                     cpx #$5a        ;successful retreived from stack?
                                trap_ne
0451 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0453 : fa                       plx
0454 : e0a5                     cpx #$a5
                                trap_ne
0456 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0458 : ecff01                   cpx $1ff        ;remains on stack?
                                trap_ne
045b : d0fe            >        bne *           ;failed not equal (non zero)
                        
045d : ba                       tsx
045e : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
0460 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0462 : c999                     cmp #$99        ;unchanged?
                                trap_ne
0464 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test            
0466 : ad0202          >            lda test_case   ;previous test
0469 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
046b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
046d : a902            >            lda #test_num   ;*** next tests' number
046f : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; test PHX does not alter flags or X but PLX does
0472 : a0aa                     ldy #$aa        ;protect y
                                set_x 1,$ff     ;push
                       >            load_flag $ff     
0474 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
0476 : 48              >            pha         ;use stack to load status
0477 : a201            >            ldx #1     ;precharge index x
0479 : 28              >            plp
                        
047a : da                       phx
                                tst_x 1,$ff
047b : 08              >            php         ;save flags
047c : e001            >            cpx #1     ;test result
                       >            trap_ne
047e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0480 : 68              >            pla         ;load status
0481 : 48              >            pha
                       >            cmp_flag $ff
0482 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0484 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0486 : 28              >            plp         ;restore status
                        
                                set_x 0,0
                       >            load_flag 0
0487 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0489 : 48              >            pha         ;use stack to load status
048a : a200            >            ldx #0     ;precharge index x
048c : 28              >            plp
                        
048d : da                       phx
                                tst_x 0,0
048e : 08              >            php         ;save flags
048f : e000            >            cpx #0     ;test result
                       >            trap_ne
0491 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0493 : 68              >            pla         ;load status
0494 : 48              >            pha
                       >            cmp_flag 0
0495 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0497 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0499 : 28              >            plp         ;restore status
                        
                                set_x $ff,$ff
                       >            load_flag $ff
049a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
049c : 48              >            pha         ;use stack to load status
049d : a2ff            >            ldx #$ff     ;precharge index x
049f : 28              >            plp
                        
04a0 : da                       phx
                                tst_x $ff,$ff
04a1 : 08              >            php         ;save flags
04a2 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
04a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
04a6 : 68              >            pla         ;load status
04a7 : 48              >            pha
                       >            cmp_flag $ff
04a8 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
04aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
04ac : 28              >            plp         ;restore status
                        
                                set_x 1,0
                       >            load_flag 0
04ad : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
04af : 48              >            pha         ;use stack to load status
04b0 : a201            >            ldx #1     ;precharge index x
04b2 : 28              >            plp
                        
04b3 : da                       phx
                                tst_x 1,0
04b4 : 08              >            php         ;save flags
04b5 : e001            >            cpx #1     ;test result
                       >            trap_ne
04b7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
04b9 : 68              >            pla         ;load status
04ba : 48              >            pha
                       >            cmp_flag 0
04bb : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
04bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
04bf : 28              >            plp         ;restore status
                        
                                set_x 0,$ff
                       >            load_flag $ff
04c0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
04c2 : 48              >            pha         ;use stack to load status
04c3 : a200            >            ldx #0     ;precharge index x
04c5 : 28              >            plp
                        
04c6 : da                       phx
                                tst_x 0,$ff
04c7 : 08              >            php         ;save flags
04c8 : e000            >            cpx #0     ;test result
                       >            trap_ne
04ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
04cc : 68              >            pla         ;load status
04cd : 48              >            pha
                       >            cmp_flag $ff
04ce : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
04d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
04d2 : 28              >            plp         ;restore status
                        
                                set_x $ff,0
                       >            load_flag 0
04d3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
04d5 : 48              >            pha         ;use stack to load status
04d6 : a2ff            >            ldx #$ff     ;precharge index x
04d8 : 28              >            plp
                        
04d9 : da                       phx
                                tst_x $ff,0
04da : 08              >            php         ;save flags
04db : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
04dd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
04df : 68              >            pla         ;load status
04e0 : 48              >            pha
                       >            cmp_flag 0
04e1 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
04e3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
04e5 : 28              >            plp         ;restore status
                        
                                set_x 0,$ff     ;pull
                       >            load_flag $ff     
04e6 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
04e8 : 48              >            pha         ;use stack to load status
04e9 : a200            >            ldx #0     ;precharge index x
04eb : 28              >            plp
                        
04ec : fa                       plx
                                tst_x $ff,$ff-zero
04ed : 08              >            php         ;save flags
04ee : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
04f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
04f2 : 68              >            pla         ;load status
04f3 : 48              >            pha
                       >            cmp_flag $ff-zero
04f4 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
04f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
04f8 : 28              >            plp         ;restore status
                        
                                set_x $ff,0
                       >            load_flag 0
04f9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
04fb : 48              >            pha         ;use stack to load status
04fc : a2ff            >            ldx #$ff     ;precharge index x
04fe : 28              >            plp
                        
04ff : fa                       plx
                                tst_x 0,zero
0500 : 08              >            php         ;save flags
0501 : e000            >            cpx #0     ;test result
                       >            trap_ne
0503 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0505 : 68              >            pla         ;load status
0506 : 48              >            pha
                       >            cmp_flag zero
0507 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0509 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
050b : 28              >            plp         ;restore status
                        
                                set_x $fe,$ff
                       >            load_flag $ff
050c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
050e : 48              >            pha         ;use stack to load status
050f : a2fe            >            ldx #$fe     ;precharge index x
0511 : 28              >            plp
                        
0512 : fa                       plx
                                tst_x 1,$ff-zero-minus
0513 : 08              >            php         ;save flags
0514 : e001            >            cpx #1     ;test result
                       >            trap_ne
0516 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0518 : 68              >            pla         ;load status
0519 : 48              >            pha
                       >            cmp_flag $ff-zero-minus
051a : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
051c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
051e : 28              >            plp         ;restore status
                        
                                set_x 0,0
                       >            load_flag 0
051f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0521 : 48              >            pha         ;use stack to load status
0522 : a200            >            ldx #0     ;precharge index x
0524 : 28              >            plp
                        
0525 : fa                       plx
                                tst_x $ff,minus
0526 : 08              >            php         ;save flags
0527 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0529 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
052b : 68              >            pla         ;load status
052c : 48              >            pha
                       >            cmp_flag minus
052d : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
052f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0531 : 28              >            plp         ;restore status
                        
                                set_x $ff,$ff
                       >            load_flag $ff
0532 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0534 : 48              >            pha         ;use stack to load status
0535 : a2ff            >            ldx #$ff     ;precharge index x
0537 : 28              >            plp
                        
0538 : fa                       plx
                                tst_x 0,$ff-minus
0539 : 08              >            php         ;save flags
053a : e000            >            cpx #0     ;test result
                       >            trap_ne
053c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
053e : 68              >            pla         ;load status
053f : 48              >            pha
                       >            cmp_flag $ff-minus
0540 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0542 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0544 : 28              >            plp         ;restore status
                        
                                set_x $fe,0
                       >            load_flag 0
0545 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0547 : 48              >            pha         ;use stack to load status
0548 : a2fe            >            ldx #$fe     ;precharge index x
054a : 28              >            plp
                        
054b : fa                       plx
                                tst_x 1,0
054c : 08              >            php         ;save flags
054d : e001            >            cpx #1     ;test result
                       >            trap_ne
054f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0551 : 68              >            pla         ;load status
0552 : 48              >            pha
                       >            cmp_flag 0
0553 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0555 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0557 : 28              >            plp         ;restore status
                        
0558 : c0aa                     cpy #$aa        ;Y unchanged
                                trap_ne
055a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test            
055c : ad0202          >            lda test_case   ;previous test
055f : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0561 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
0563 : a903            >            lda #test_num   ;*** next tests' number
0565 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test PHY does not alter flags or Y but PLY does
0568 : a255                     ldx #$55        ;x & a protected
                                set_y 1,$ff     ;push
                       >            load_flag $ff     
056a : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
056c : 48              >            pha         ;use stack to load status
056d : a001            >            ldy #1     ;precharge index y
056f : 28              >            plp
                        
0570 : 5a                       phy
                                tst_y 1,$ff
0571 : 08              >            php         ;save flags
0572 : c001            >            cpy #1     ;test result
                       >            trap_ne
0574 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0576 : 68              >            pla         ;load status
0577 : 48              >            pha
                       >            cmp_flag $ff
0578 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
057a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
057c : 28              >            plp         ;restore status
                        
                                set_y 0,0
                       >            load_flag 0
057d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
057f : 48              >            pha         ;use stack to load status
0580 : a000            >            ldy #0     ;precharge index y
0582 : 28              >            plp
                        
0583 : 5a                       phy
                                tst_y 0,0
0584 : 08              >            php         ;save flags
0585 : c000            >            cpy #0     ;test result
                       >            trap_ne
0587 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0589 : 68              >            pla         ;load status
058a : 48              >            pha
                       >            cmp_flag 0
058b : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
058d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
058f : 28              >            plp         ;restore status
                        
                                set_y $ff,$ff
                       >            load_flag $ff
0590 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0592 : 48              >            pha         ;use stack to load status
0593 : a0ff            >            ldy #$ff     ;precharge index y
0595 : 28              >            plp
                        
0596 : 5a                       phy
                                tst_y $ff,$ff
0597 : 08              >            php         ;save flags
0598 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
059a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
059c : 68              >            pla         ;load status
059d : 48              >            pha
                       >            cmp_flag $ff
059e : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
05a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
05a2 : 28              >            plp         ;restore status
                        
                                set_y 1,0
                       >            load_flag 0
05a3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
05a5 : 48              >            pha         ;use stack to load status
05a6 : a001            >            ldy #1     ;precharge index y
05a8 : 28              >            plp
                        
05a9 : 5a                       phy
                                tst_y 1,0
05aa : 08              >            php         ;save flags
05ab : c001            >            cpy #1     ;test result
                       >            trap_ne
05ad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
05af : 68              >            pla         ;load status
05b0 : 48              >            pha
                       >            cmp_flag 0
05b1 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
05b3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
05b5 : 28              >            plp         ;restore status
                        
                                set_y 0,$ff
                       >            load_flag $ff
05b6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
05b8 : 48              >            pha         ;use stack to load status
05b9 : a000            >            ldy #0     ;precharge index y
05bb : 28              >            plp
                        
05bc : 5a                       phy
                                tst_y 0,$ff
05bd : 08              >            php         ;save flags
05be : c000            >            cpy #0     ;test result
                       >            trap_ne
05c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
05c2 : 68              >            pla         ;load status
05c3 : 48              >            pha
                       >            cmp_flag $ff
05c4 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
05c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
05c8 : 28              >            plp         ;restore status
                        
                                set_y $ff,0
                       >            load_flag 0
05c9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
05cb : 48              >            pha         ;use stack to load status
05cc : a0ff            >            ldy #$ff     ;precharge index y
05ce : 28              >            plp
                        
05cf : 5a                       phy
                                tst_y $ff,0
05d0 : 08              >            php         ;save flags
05d1 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
05d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
05d5 : 68              >            pla         ;load status
05d6 : 48              >            pha
                       >            cmp_flag 0
05d7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
05d9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
05db : 28              >            plp         ;restore status
                        
                                set_y 0,$ff     ;pull
                       >            load_flag $ff     
05dc : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
05de : 48              >            pha         ;use stack to load status
05df : a000            >            ldy #0     ;precharge index y
05e1 : 28              >            plp
                        
05e2 : 7a                       ply
                                tst_y $ff,$ff-zero
05e3 : 08              >            php         ;save flags
05e4 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
05e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
05e8 : 68              >            pla         ;load status
05e9 : 48              >            pha
                       >            cmp_flag $ff-zero
05ea : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
05ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
05ee : 28              >            plp         ;restore status
                        
                                set_y $ff,0
                       >            load_flag 0
05ef : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
05f1 : 48              >            pha         ;use stack to load status
05f2 : a0ff            >            ldy #$ff     ;precharge index y
05f4 : 28              >            plp
                        
05f5 : 7a                       ply
                                tst_y 0,zero
05f6 : 08              >            php         ;save flags
05f7 : c000            >            cpy #0     ;test result
                       >            trap_ne
05f9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
05fb : 68              >            pla         ;load status
05fc : 48              >            pha
                       >            cmp_flag zero
05fd : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
05ff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0601 : 28              >            plp         ;restore status
                        
                                set_y $fe,$ff
                       >            load_flag $ff
0602 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0604 : 48              >            pha         ;use stack to load status
0605 : a0fe            >            ldy #$fe     ;precharge index y
0607 : 28              >            plp
                        
0608 : 7a                       ply
                                tst_y 1,$ff-zero-minus
0609 : 08              >            php         ;save flags
060a : c001            >            cpy #1     ;test result
                       >            trap_ne
060c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
060e : 68              >            pla         ;load status
060f : 48              >            pha
                       >            cmp_flag $ff-zero-minus
0610 : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0612 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0614 : 28              >            plp         ;restore status
                        
                                set_y 0,0
                       >            load_flag 0
0615 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0617 : 48              >            pha         ;use stack to load status
0618 : a000            >            ldy #0     ;precharge index y
061a : 28              >            plp
                        
061b : 7a                       ply
                                tst_y $ff,minus
061c : 08              >            php         ;save flags
061d : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
061f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0621 : 68              >            pla         ;load status
0622 : 48              >            pha
                       >            cmp_flag minus
0623 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0625 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0627 : 28              >            plp         ;restore status
                        
                                set_y $ff,$ff
                       >            load_flag $ff
0628 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
062a : 48              >            pha         ;use stack to load status
062b : a0ff            >            ldy #$ff     ;precharge index y
062d : 28              >            plp
                        
062e : 7a                       ply
                                tst_y 0,$ff-minus
062f : 08              >            php         ;save flags
0630 : c000            >            cpy #0     ;test result
                       >            trap_ne
0632 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0634 : 68              >            pla         ;load status
0635 : 48              >            pha
                       >            cmp_flag $ff-minus
0636 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0638 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
063a : 28              >            plp         ;restore status
                        
                                set_y $fe,0
                       >            load_flag 0
063b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
063d : 48              >            pha         ;use stack to load status
063e : a0fe            >            ldy #$fe     ;precharge index y
0640 : 28              >            plp
                        
0641 : 7a                       ply
                                tst_y 1,0
0642 : 08              >            php         ;save flags
0643 : c001            >            cpy #1     ;test result
                       >            trap_ne
0645 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0647 : 68              >            pla         ;load status
0648 : 48              >            pha
                       >            cmp_flag 0
0649 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
064b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
064d : 28              >            plp         ;restore status
                        
064e : e055                     cpx #$55        ;x unchanged?
                                trap_ne
0650 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test            
0652 : ad0202          >            lda test_case   ;previous test
0655 : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0657 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
0659 : a904            >            lda #test_num   ;*** next tests' number
065b : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; PC modifying instructions (BRA, BBR, BBS, 1, 2, 3 byte NOPs, JMP(abs,x))
                        ; testing unconditional branch BRA
                        
065e : a281                     ldx #$81        ;protect unused registers
0660 : a07e                     ldy #$7e
                                set_a 0,$ff
                       >            load_flag $ff
0662 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0664 : 48              >            pha         ;use stack to load status
0665 : a900            >            lda #0     ;precharge accu
0667 : 28              >            plp
                        
0668 : 8003                     bra br1         ;branch should always be taken
                                trap 
066a : 4c6a06          >        jmp *           ;failed anyway
                        
066d :                  br1
                                tst_a 0,$ff
066d : 08              >            php         ;save flags
066e : c900            >            cmp #0     ;test result
                       >            trap_ne
0670 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0672 : 68              >            pla         ;load status
0673 : 48              >            pha
                       >            cmp_flag $ff
0674 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0676 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0678 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
0679 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
067b : 48              >            pha         ;use stack to load status
067c : a9ff            >            lda #$ff     ;precharge accu
067e : 28              >            plp
                        
067f : 8003                     bra br2         ;branch should always be taken
                                trap 
0681 : 4c8106          >        jmp *           ;failed anyway
                        
0684 :                  br2
                                tst_a $ff,0
0684 : 08              >            php         ;save flags
0685 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0687 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0689 : 68              >            pla         ;load status
068a : 48              >            pha
                       >            cmp_flag 0
068b : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
068d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
068f : 28              >            plp         ;restore status
                        
0690 : e081                     cpx #$81
                                trap_ne
0692 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0694 : c07e                     cpy #$7e
                                trap_ne
0696 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test            
0698 : ad0202          >            lda test_case   ;previous test
069b : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
069d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
069f : a905            >            lda #test_num   ;*** next tests' number
06a1 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
06a4 : a000                     ldy #0          ;branch range test  
06a6 : 8061                     bra bra0
                                
06a8 : c001             bra1    cpy #1
                                trap_ne         ;long range backward
06aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
06ac : c8                       iny        
06ad : 8053                     bra bra2
                                        
06af : c003             bra3    cpy #3
                                trap_ne         ;long range backward
06b1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
06b3 : c8                       iny        
06b4 : 8045                     bra bra4
                                        
06b6 : c005             bra5    cpy #5
                                trap_ne         ;long range backward
06b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
06ba : c8                       iny        
06bb : a000                     ldy #0
06bd : 8004                     bra brf0
                                
06bf : c8                       iny
06c0 : c8                       iny
06c1 : c8                       iny
06c2 : c8                       iny        
06c3 : 8003             brf0    bra brf1
                        
06c5 : c8                       iny
06c6 : c8                       iny
06c7 : c8                       iny
06c8 : c8               brf1    iny        
06c9 : 8002                     bra brf2
                                
06cb : c8                       iny
06cc : c8                       iny
06cd : c8               brf2    iny
06ce : c8                       iny        
06cf : 8001                     bra brf3
                                
06d1 : c8                       iny
06d2 : c8               brf3    iny
06d3 : c8                       iny
06d4 : c8                       iny        
06d5 : 8000                     bra brf4
                                
06d7 : c8               brf4    iny
06d8 : c8                       iny
06d9 : c8                       iny
06da : c8                       iny
06db : c00a                     cpy #10
                                trap_ne     ;short range forward
06dd : d0fe            >        bne *           ;failed not equal (non zero)
                        
06df : 8012                     bra brb0
                        
06e1 : 88               brb4    dey
06e2 : 88                       dey
06e3 : 88                       dey
06e4 : 88                       dey
06e5 : 800e                     bra brb5        
                        
06e7 : 88               brb3    dey
06e8 : 88                       dey
06e9 : 88                       dey
06ea : 80f5                     bra brb4        
                        
06ec : 88               brb2    dey
06ed : 88                       dey
06ee : 80f7                     bra brb3        
                        
06f0 : 88               brb1    dey
06f1 : 80f9                     bra brb2        
                        
06f3 : 80fb             brb0    bra brb1        
                        
06f5 : c000             brb5    cpy #0
                                trap_ne     ;short range backward
06f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
06f9 : 8015                     bra bra6
                        
06fb : c004             bra4    cpy #4
                                trap_ne     ;long range forward
06fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
06ff : c8                       iny        
0700 : 80b4                     bra bra5
                                        
0702 : c002             bra2    cpy #2
                                trap_ne     ;long range forward
0704 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0706 : c8                       iny        
0707 : 80a6                     bra bra3
                                        
0709 : c000             bra0    cpy #0
                                trap_ne     ;long range forward
070b : d0fe            >        bne *           ;failed not equal (non zero)
                        
070d : c8                       iny        
070e : 8098                     bra bra1
                                        
0710 :                  bra6
                                next_test
0710 : ad0202          >            lda test_case   ;previous test
0713 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0715 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
0717 : a906            >            lda #test_num   ;*** next tests' number
0719 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                            if rkwl_wdc_op = 1
                        ; testing BBR & BBS
                        
                        bbt     macro           ;\1 = bitnum
                                lda #(1<<\1)    ;testing 1 bit on
                                sta zpt
                                set_a $33,0     ;with flags off
                                bbr \1,zpt,fail1\?
                                bbs \1,zpt,ok1\?
                                trap            ;bbs branch not taken
                        fail1\?
                                trap            ;bbr branch taken
                        ok1\?   
                                tst_a $33,0
                                set_a $cc,$ff   ;with flags on
                                bbr \1,zpt,fail2\?
                                bbs \1,zpt,ok2\?
                                trap            ;bbs branch not taken
                        fail2\? 
                                trap            ;bbr branch taken
                        ok2\?   
                                tst_a $cc,$ff
                                lda zpt
                                cmp #(1<<\1)
                                trap_ne         ;zp altered
                                lda #$ff-(1<<\1) ;testing 1 bit off
                                sta zpt
                                set_a $33,0     ;with flags off
                                bbs \1,zpt,fail3\?
                                bbr \1,zpt,ok3\?
                                trap            ;bbr branch not taken
                        fail3\? 
                                trap            ;bbs branch taken
                        ok3\?   
                                tst_a $33,0
                                set_a $cc,$ff   ;with flags on
                                bbs \1,zpt,fail4\?
                                bbr \1,zpt,ok4\?
                                trap            ;bbr branch not taken
                        fail4\? 
                                trap            ;bbs branch taken
                        ok4\?   
                                tst_a $cc,$ff
                                lda zpt
                                cmp #$ff-(1<<\1)
                                trap_ne         ;zp altered
                                endm
                        
                                ldx #$11        ;test bbr/bbs integrity
                                ldy #$22
                                bbt 0
                                bbt 1
                                bbt 2
                                bbt 3
                                bbt 4
                                bbt 5
                                bbt 6
                                bbt 7
                                cpx #$11
                                trap_ne         ;x overwritten
                                cpy #$22
                                trap_ne         ;y overwritten
                                next_test 
                        
                        bbrc    macro           ;\1 = bitnum
                                bbr \1,zpt,skip\?
                                eor #(1<<\1)       
                        skip\?
                                endm
                        bbsc    macro           ;\1 = bitnum
                                bbs \1,zpt,skip\?
                                eor #(1<<\1)       
                        skip\?
                                endm
                        
                                lda #0          ;combined bit test
                                sta zpt
                        bbcl    lda #0
                                bbrc 0
                                bbrc 1
                                bbrc 2
                                bbrc 3
                                bbrc 4
                                bbrc 5
                                bbrc 6
                                bbrc 7
                                eor zpt
                                trap_ne         ;failed bbr bitnum in accu       
                                lda #$ff
                                bbsc 0
                                bbsc 1
                                bbsc 2
                                bbsc 3
                                bbsc 4
                                bbsc 5
                                bbsc 6
                                bbsc 7
                                eor zpt
                                trap_ne         ;failed bbs bitnum in accu       
                                inc zpt
                                bne bbcl
                                next_test            
                            endif
                            
                        ; testing NOP
                        
                        nop_test    macro       ;\1 = opcode, \2 = # of bytes
                                    ldy #$42
                                    ldx #4-\2
                                    db  \1          ;test nop length
                                if \2 = 1
                                    dex
                                    dex
                                endif
                                if \2 = 2
                                    iny
                                    dex
                                endif
                                if \2 = 3
                                    iny
                                    iny
                                endif
                                    dex
                                    trap_ne         ;wrong number of bytes
                                    set_a $ff-\1,0
                                    db  \1          ;test nop integrity - flags off
                                    nop
                                    nop
                                    tst_a $ff-\1,0
                                    set_a $aa-\1,$ff
                                    db  \1          ;test nop integrity - flags on
                                    nop
                                    nop
                                    tst_a $aa-\1,$ff
                                    cpy #$42
                                    trap_ne         ;y changed
                                    cpx #0
                                    trap_ne         ;x changed
                                    endm
                        
                            if skip_nop = 0
                                nop_test $02,2
                                nop_test $22,2
                                nop_test $42,2
                                nop_test $62,2
                                nop_test $82,2
                                nop_test $c2,2
                                nop_test $e2,2
                                nop_test $44,2
                                nop_test $54,2
                                nop_test $d4,2
                                nop_test $f4,2
                                nop_test $5c,3
                                nop_test $dc,3
                                nop_test $fc,3
                                nop_test $03,1
                                nop_test $13,1
                                nop_test $23,1
                                nop_test $33,1
                                nop_test $43,1
                                nop_test $53,1
                                nop_test $63,1
                                nop_test $73,1
                                nop_test $83,1
                                nop_test $93,1
                                nop_test $a3,1
                                nop_test $b3,1
                                nop_test $c3,1
                                nop_test $d3,1
                                nop_test $e3,1
                                nop_test $f3,1
                                nop_test $0b,1
                                nop_test $1b,1
                                nop_test $2b,1
                                nop_test $3b,1
                                nop_test $4b,1
                                nop_test $5b,1
                                nop_test $6b,1
                                nop_test $7b,1
                                nop_test $8b,1
                                nop_test $9b,1
                                nop_test $ab,1
                                nop_test $bb,1
                                nop_test $eb,1
                                nop_test $fb,1
                            if rkwl_wdc_op = 0      ;NOPs not available on Rockwell & WDC 65C02
                                nop_test $07,1
                                nop_test $17,1
                                nop_test $27,1
                                nop_test $37,1
                                nop_test $47,1
                                nop_test $57,1
                                nop_test $67,1
                                nop_test $77,1
                                nop_test $87,1
                                nop_test $97,1
                                nop_test $a7,1
                                nop_test $b7,1
                                nop_test $c7,1
                                nop_test $d7,1
                                nop_test $e7,1
                                nop_test $f7,1
                                nop_test $0f,1
                                nop_test $1f,1
                                nop_test $2f,1
                                nop_test $3f,1
                                nop_test $4f,1
                                nop_test $5f,1
                                nop_test $6f,1
                                nop_test $7f,1
                                nop_test $8f,1
                                nop_test $9f,1
                                nop_test $af,1
                                nop_test $bf,1
                                nop_test $cf,1
                                nop_test $df,1
                                nop_test $ef,1
                                nop_test $ff,1
                            endif
                            if  wdc_op = 0          ;NOPs not available on WDC 65C02 (WAI, STP)
                                nop_test $cb,1
                                nop_test $db,1
                            endif
                                next_test
                            endif
                                    
                        ; jump indirect (test page cross bug is fixed)
071c : a203                     ldx #3          ;prepare table
071e : bd7a13           ji1     lda ji_adr,x
0721 : 9dfd02                   sta ji_tab,x
0724 : ca                       dex
0725 : 10f7                     bpl ji1
0727 : a915                     lda #hi(ji_px) ;high address if page cross bug
0729 : 8d0002                   sta pg_x
                                set_stat 0
                       >            load_flag 0
072c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
072e : 48              >            pha         ;use stack to load status
072f : 28              >            plp
                        
0730 : a949                     lda #'I'
0732 : a24e                     ldx #'N'
0734 : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
0736 : 6cfd02                   jmp (ji_tab)
0739 : ea                       nop
                                trap_ne         ;runover protection
073a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
073c : 88                       dey
073d : 88                       dey
073e : 08               ji_ret  php             ;either SP or Y count will fail, if we do not hit
073f : 88                       dey
0740 : 88                       dey
0741 : 88                       dey
0742 : 28                       plp
                                trap_eq         ;returned flags OK?
0743 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0745 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0747 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0749 : 50fe            >        bvc *           ;failed overflow clear
                        
074b : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
074d : d0fe            >        bne *           ;failed not equal (non zero)
                        
074f : e04f                     cpx #('N'+1)
                                trap_ne
0751 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0753 : c03e                     cpy #('D'-6)
                                trap_ne
0755 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0757 : ba                       tsx             ;SP check
0758 : e0ff                     cpx #$ff
                                trap_ne
075a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
075c : ad0202          >            lda test_case   ;previous test
075f : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0761 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
0763 : a907            >            lda #test_num   ;*** next tests' number
0765 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump indexed indirect
0768 : a20b                     ldx #11         ;prepare table
076a : bdb613           jxi1    lda jxi_adr,x
076d : 9df902                   sta jxi_tab,x
0770 : ca                       dex
0771 : 10f7                     bpl jxi1
0773 : a915                     lda #hi(jxi_px) ;high address if page cross bug
0775 : 8d0002                   sta pg_x
                                set_stat 0
                       >            load_flag 0
0778 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
077a : 48              >            pha         ;use stack to load status
077b : 28              >            plp
                        
077c : a958                     lda #'X'
077e : a204                     ldx #4
0780 : a049                     ldy #'I'        ;N=0, V=0, Z=0, C=0
0782 : 7cf902                   jmp (jxi_tab,x)
0785 : ea                       nop
                                trap_ne         ;runover protection
0786 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
0788 : 88                       dey
0789 : 88                       dey
078a : 08               jxi_ret php             ;either SP or Y count will fail, if we do not hit
078b : 88                       dey
078c : 88                       dey
078d : 88                       dey
078e : 28                       plp
                                trap_eq         ;returned flags OK?
078f : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0791 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0793 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0795 : 50fe            >        bvc *           ;failed overflow clear
                        
0797 : c9f2                     cmp #('X'^$aa)  ;returned registers OK?
                                trap_ne
0799 : d0fe            >        bne *           ;failed not equal (non zero)
                        
079b : e006                     cpx #6
                                trap_ne
079d : d0fe            >        bne *           ;failed not equal (non zero)
                        
079f : c043                     cpy #('I'-6)
                                trap_ne
07a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
07a3 : ba                       tsx             ;SP check
07a4 : e0ff                     cpx #$ff
                                trap_ne
07a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
07a8 : a9c4                     lda #lo(jxp_ok) ;test with index causing a page cross
07aa : 8d0003                   sta jxp_tab
07ad : a907                     lda #hi(jxp_ok)
07af : 8d0103                   sta jxp_tab+1
07b2 : a9c1                     lda #lo(jxp_px)
07b4 : 8d0002                   sta pg_x
07b7 : a907                     lda #hi(jxp_px)
07b9 : 8d0102                   sta pg_x+1
07bc : a2ff                     ldx #$ff
07be : 7c0102                   jmp (jxp_tab-$ff,x)
                                
07c1 :                  jxp_px  
                                trap            ;page cross by index to wrong page
07c1 : 4cc107          >        jmp *           ;failed anyway
                        
                        
07c4 :                  jxp_ok
                                next_test
07c4 : ad0202          >            lda test_case   ;previous test
07c7 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
07c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
07cb : a908            >            lda #test_num   ;*** next tests' number
07cd : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if ROM_vectors = 1
                        ; test BRK clears decimal mode
                                load_flag 0     ;with interrupts enabled if allowed!
07d0 : a900            >            lda #0                  ;allow test to change I-flag (no mask)
                        
07d2 : 48                       pha
07d3 : a942                     lda #'B'
07d5 : a252                     ldx #'R'
07d7 : a04b                     ldy #'K'
07d9 : 28                       plp             ;N=0, V=0, Z=0, C=0
07da : 00                       brk
07db : 88                       dey             ;should not be executed
07dc :                  brk_ret0                ;address of break return
07dc : 08                       php             ;either SP or Y count will fail, if we do not hit
07dd : 88                       dey
07de : 88                       dey
07df : 88                       dey
07e0 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
07e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
07e4 : e053                     cpx #'R'+1
                                trap_ne
07e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
07e8 : c045                     cpy #'K'-6
                                trap_ne
07ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
07ec : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
07ed : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
07ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
07f1 : ba                       tsx             ;sp?
07f2 : e0ff                     cpx #$ff
                                trap_ne
07f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        ;pass 2
                                load_flag $ff   ;with interrupts disabled if allowed!
07f6 : a9ff            >            lda #$ff                ;allow test to change I-flag (no mask)
                        
07f8 : 48                       pha
07f9 : a9bd                     lda #$ff-'B'
07fb : a2ad                     ldx #$ff-'R'
07fd : a0b4                     ldy #$ff-'K'
07ff : 28                       plp             ;N=1, V=1, Z=1, C=1
0800 : 00                       brk
0801 : 88                       dey             ;should not be executed
0802 :                  brk_ret1                ;address of break return
0802 : 08                       php             ;either SP or Y count will fail, if we do not hit
0803 : 88                       dey
0804 : 88                       dey
0805 : 88                       dey
0806 : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
0808 : d0fe            >        bne *           ;failed not equal (non zero)
                        
080a : e0ae                     cpx #$ff-'R'+1
                                trap_ne
080c : d0fe            >        bne *           ;failed not equal (non zero)
                        
080e : c0ae                     cpy #$ff-'K'-6
                                trap_ne
0810 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0812 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
0813 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0815 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0817 : ba                       tsx             ;sp?
0818 : e0ff                     cpx #$ff
                                trap_ne
081a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
081c : ad0202          >            lda test_case   ;previous test
081f : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0821 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
0823 : a909            >            lda #test_num   ;*** next tests' number
0825 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                            endif
                         
                        ; testing accumulator increment/decrement INC A & DEC A
0828 : a2ac                     ldx #$ac    ;protect x & y
082a : a0dc                     ldy #$dc
                                set_a $fe,$ff
                       >            load_flag $ff
082c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
082e : 48              >            pha         ;use stack to load status
082f : a9fe            >            lda #$fe     ;precharge accu
0831 : 28              >            plp
                        
0832 : 1a                       inc a           ;ff
                                tst_as $ff,$ff-zero
0833 : 48              >            pha
0834 : 08              >            php         ;save flags
0835 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0837 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0839 : 68              >            pla         ;load status
083a : 48              >            pha
                       >            cmp_flag $ff-zero
083b : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
083d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
083f : 28              >            plp         ;restore status
0840 : 68              >            pla
                        
0841 : 1a                       inc a           ;00
                                tst_as 0,$ff-minus
0842 : 48              >            pha
0843 : 08              >            php         ;save flags
0844 : c900            >            cmp #0     ;test result
                       >            trap_ne
0846 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0848 : 68              >            pla         ;load status
0849 : 48              >            pha
                       >            cmp_flag $ff-minus
084a : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
084c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
084e : 28              >            plp         ;restore status
084f : 68              >            pla
                        
0850 : 1a                       inc a           ;01
                                tst_as 1,$ff-minus-zero
0851 : 48              >            pha
0852 : 08              >            php         ;save flags
0853 : c901            >            cmp #1     ;test result
                       >            trap_ne
0855 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0857 : 68              >            pla         ;load status
0858 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0859 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
085b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
085d : 28              >            plp         ;restore status
085e : 68              >            pla
                        
085f : 3a                       dec a           ;00
                                tst_as 0,$ff-minus
0860 : 48              >            pha
0861 : 08              >            php         ;save flags
0862 : c900            >            cmp #0     ;test result
                       >            trap_ne
0864 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0866 : 68              >            pla         ;load status
0867 : 48              >            pha
                       >            cmp_flag $ff-minus
0868 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
086a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
086c : 28              >            plp         ;restore status
086d : 68              >            pla
                        
086e : 3a                       dec a           ;ff
                                tst_as $ff,$ff-zero
086f : 48              >            pha
0870 : 08              >            php         ;save flags
0871 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0873 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0875 : 68              >            pla         ;load status
0876 : 48              >            pha
                       >            cmp_flag $ff-zero
0877 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0879 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
087b : 28              >            plp         ;restore status
087c : 68              >            pla
                        
087d : 3a                       dec a           ;fe
                                set_a $fe,0
                       >            load_flag 0
087e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0880 : 48              >            pha         ;use stack to load status
0881 : a9fe            >            lda #$fe     ;precharge accu
0883 : 28              >            plp
                        
0884 : 1a                       inc a           ;ff
                                tst_as $ff,minus
0885 : 48              >            pha
0886 : 08              >            php         ;save flags
0887 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0889 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
088b : 68              >            pla         ;load status
088c : 48              >            pha
                       >            cmp_flag minus
088d : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
088f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0891 : 28              >            plp         ;restore status
0892 : 68              >            pla
                        
0893 : 1a                       inc a           ;00
                                tst_as 0,zero
0894 : 48              >            pha
0895 : 08              >            php         ;save flags
0896 : c900            >            cmp #0     ;test result
                       >            trap_ne
0898 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
089a : 68              >            pla         ;load status
089b : 48              >            pha
                       >            cmp_flag zero
089c : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
089e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08a0 : 28              >            plp         ;restore status
08a1 : 68              >            pla
                        
08a2 : 1a                       inc a           ;01
                                tst_as 1,0
08a3 : 48              >            pha
08a4 : 08              >            php         ;save flags
08a5 : c901            >            cmp #1     ;test result
                       >            trap_ne
08a7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08a9 : 68              >            pla         ;load status
08aa : 48              >            pha
                       >            cmp_flag 0
08ab : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08ad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08af : 28              >            plp         ;restore status
08b0 : 68              >            pla
                        
08b1 : 3a                       dec a           ;00
                                tst_as 0,zero
08b2 : 48              >            pha
08b3 : 08              >            php         ;save flags
08b4 : c900            >            cmp #0     ;test result
                       >            trap_ne
08b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08b8 : 68              >            pla         ;load status
08b9 : 48              >            pha
                       >            cmp_flag zero
08ba : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08be : 28              >            plp         ;restore status
08bf : 68              >            pla
                        
08c0 : 3a                       dec a           ;ff
                                tst_as $ff,minus
08c1 : 48              >            pha
08c2 : 08              >            php         ;save flags
08c3 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
08c5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c7 : 68              >            pla         ;load status
08c8 : 48              >            pha
                       >            cmp_flag minus
08c9 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08cd : 28              >            plp         ;restore status
08ce : 68              >            pla
                        
08cf : e0ac                     cpx #$ac
                                trap_ne     ;x altered during test
08d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
08d3 : c0dc                     cpy #$dc
                                trap_ne     ;y altered during test
08d5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
08d7 : ba                       tsx
08d8 : e0ff                     cpx #$ff
                                trap_ne     ;sp push/pop mismatch
08da : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
08dc : ad0202          >            lda test_case   ;previous test
08df : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
08e3 : a90a            >            lda #test_num   ;*** next tests' number
08e5 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA (zp)
08e8 : a299                     ldx #$99    ;protect x & y
08ea : a066                     ldy #$66
                                set_stat 0  
                       >            load_flag 0  
08ec : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
08ee : 48              >            pha         ;use stack to load status
08ef : 28              >            plp
                        
08f0 : b224                     lda (ind1)
08f2 : 08                       php         ;test stores do not alter flags
08f3 : 49c3                     eor #$c3
08f5 : 28                       plp
08f6 : 9230                     sta (indt)
08f8 : 08                       php         ;flags after load/store sequence
08f9 : 49c3                     eor #$c3
08fb : c9c3                     cmp #$c3    ;test result
                                trap_ne
08fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
08ff : 68                       pla         ;load status
                                eor_flag 0
0900 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0902 : cd1502                   cmp fLDx    ;test flags
                                trap_ne
0905 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0907 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0909 : 48              >            pha         ;use stack to load status
090a : 28              >            plp
                        
090b : b226                     lda (ind1+2)
090d : 08                       php         ;test stores do not alter flags
090e : 49c3                     eor #$c3
0910 : 28                       plp
0911 : 9232                     sta (indt+2)
0913 : 08                       php         ;flags after load/store sequence
0914 : 49c3                     eor #$c3
0916 : c982                     cmp #$82    ;test result
                                trap_ne
0918 : d0fe            >        bne *           ;failed not equal (non zero)
                        
091a : 68                       pla         ;load status
                                eor_flag 0
091b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
091d : cd1602                   cmp fLDx+1  ;test flags
                                trap_ne
0920 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0922 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0924 : 48              >            pha         ;use stack to load status
0925 : 28              >            plp
                        
0926 : b228                     lda (ind1+4)
0928 : 08                       php         ;test stores do not alter flags
0929 : 49c3                     eor #$c3
092b : 28                       plp
092c : 9234                     sta (indt+4)
092e : 08                       php         ;flags after load/store sequence
092f : 49c3                     eor #$c3
0931 : c941                     cmp #$41    ;test result
                                trap_ne
0933 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0935 : 68                       pla         ;load status
                                eor_flag 0
0936 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0938 : cd1702                   cmp fLDx+2  ;test flags
                                trap_ne
093b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
093d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
093f : 48              >            pha         ;use stack to load status
0940 : 28              >            plp
                        
0941 : b22a                     lda (ind1+6)
0943 : 08                       php         ;test stores do not alter flags
0944 : 49c3                     eor #$c3
0946 : 28                       plp
0947 : 9236                     sta (indt+6)
0949 : 08                       php         ;flags after load/store sequence
094a : 49c3                     eor #$c3
094c : c900                     cmp #0      ;test result
                                trap_ne
094e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0950 : 68                       pla         ;load status
                                eor_flag 0
0951 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0953 : cd1802                   cmp fLDx+3  ;test flags
                                trap_ne
0956 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0958 : e099                     cpx #$99
                                trap_ne     ;x altered during test
095a : d0fe            >        bne *           ;failed not equal (non zero)
                        
095c : c066                     cpy #$66
                                trap_ne     ;y altered during test
095e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
0960 : a003                     ldy #3      ;testing store result
0962 : a200                     ldx #0
0964 : b90502           tstai1  lda abst,y
0967 : 49c3                     eor #$c3
0969 : d91002                   cmp abs1,y
                                trap_ne     ;store to indirect data
096c : d0fe            >        bne *           ;failed not equal (non zero)
                        
096e : 8a                       txa
096f : 990502                   sta abst,y  ;clear                
0972 : 88                       dey
0973 : 10ef                     bpl tstai1
                        
0975 : a299                     ldx #$99    ;protect x & y
0977 : a066                     ldy #$66
                                set_stat $ff  
                       >            load_flag $ff  
0979 : a9ff            >            lda #$ff               ;allow test to change I-flag (no mask)
                       >
097b : 48              >            pha         ;use stack to load status
097c : 28              >            plp
                        
097d : b224                     lda (ind1)
097f : 08                       php         ;test stores do not alter flags
0980 : 49c3                     eor #$c3
0982 : 28                       plp
0983 : 9230                     sta (indt)
0985 : 08                       php         ;flags after load/store sequence
0986 : 49c3                     eor #$c3
0988 : c9c3                     cmp #$c3    ;test result
                                trap_ne
098a : d0fe            >        bne *           ;failed not equal (non zero)
                        
098c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
098d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
098f : cd1502                   cmp fLDx    ;test flags
                                trap_ne
0992 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0994 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0996 : 48              >            pha         ;use stack to load status
0997 : 28              >            plp
                        
0998 : b226                     lda (ind1+2)
099a : 08                       php         ;test stores do not alter flags
099b : 49c3                     eor #$c3
099d : 28                       plp
099e : 9232                     sta (indt+2)
09a0 : 08                       php         ;flags after load/store sequence
09a1 : 49c3                     eor #$c3
09a3 : c982                     cmp #$82    ;test result
                                trap_ne
09a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09a7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
09a8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
09aa : cd1602                   cmp fLDx+1  ;test flags
                                trap_ne
09ad : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
09af : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
09b1 : 48              >            pha         ;use stack to load status
09b2 : 28              >            plp
                        
09b3 : b228                     lda (ind1+4)
09b5 : 08                       php         ;test stores do not alter flags
09b6 : 49c3                     eor #$c3
09b8 : 28                       plp
09b9 : 9234                     sta (indt+4)
09bb : 08                       php         ;flags after load/store sequence
09bc : 49c3                     eor #$c3
09be : c941                     cmp #$41    ;test result
                                trap_ne
09c0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09c2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
09c3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
09c5 : cd1702                   cmp fLDx+2  ;test flags
                                trap_ne
09c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
09ca : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
09cc : 48              >            pha         ;use stack to load status
09cd : 28              >            plp
                        
09ce : b22a                     lda (ind1+6)
09d0 : 08                       php         ;test stores do not alter flags
09d1 : 49c3                     eor #$c3
09d3 : 28                       plp
09d4 : 9236                     sta (indt+6)
09d6 : 08                       php         ;flags after load/store sequence
09d7 : 49c3                     eor #$c3
09d9 : c900                     cmp #0      ;test result
                                trap_ne
09db : d0fe            >        bne *           ;failed not equal (non zero)
                        
09dd : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
09de : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
09e0 : cd1802                   cmp fLDx+3  ;test flags
                                trap_ne
09e3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e5 : e099                     cpx #$99
                                trap_ne     ;x altered during test
09e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09e9 : c066                     cpy #$66
                                trap_ne     ;y altered during test
09eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
09ed : a003                     ldy #3      ;testing store result
09ef : a200                     ldx #0
09f1 : b90502           tstai2  lda abst,y
09f4 : 49c3                     eor #$c3
09f6 : d91002                   cmp abs1,y
                                trap_ne     ;store to indirect data
09f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09fb : 8a                       txa
09fc : 990502                   sta abst,y  ;clear                
09ff : 88                       dey
0a00 : 10ef                     bpl tstai2
0a02 : ba                       tsx
0a03 : e0ff                     cpx #$ff
                                trap_ne     ;sp push/pop mismatch
0a05 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0a07 : ad0202          >            lda test_case   ;previous test
0a0a : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
0a0e : a90b            >            lda #test_num   ;*** next tests' number
0a10 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing STZ - zp / abs / zp,x / abs,x
0a13 : a07b                     ldy #123    ;protect y
0a15 : a204                     ldx #4      ;precharge test area
0a17 : a907                     lda #7
0a19 : 950c             tstz1   sta zpt,x
0a1b : 0a                       asl a
0a1c : ca                       dex
0a1d : 10fa                     bpl tstz1
0a1f : a204                     ldx #4
                                set_a $55,$ff
                       >            load_flag $ff
0a21 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0a23 : 48              >            pha         ;use stack to load status
0a24 : a955            >            lda #$55     ;precharge accu
0a26 : 28              >            plp
                        
0a27 : 640c                     stz zpt     
0a29 : 640d                     stz zpt+1
0a2b : 640e                     stz zpt+2
0a2d : 640f                     stz zpt+3
0a2f : 6410                     stz zpt+4
                                tst_a $55,$ff
0a31 : 08              >            php         ;save flags
0a32 : c955            >            cmp #$55     ;test result
                       >            trap_ne
0a34 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a36 : 68              >            pla         ;load status
0a37 : 48              >            pha
                       >            cmp_flag $ff
0a38 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a3c : 28              >            plp         ;restore status
                        
0a3d : b50c             tstz2   lda zpt,x   ;verify zeros stored
                                trap_ne     ;non zero after STZ zp
0a3f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a41 : ca                       dex
0a42 : 10f9                     bpl tstz2
0a44 : a204                     ldx #4      ;precharge test area
0a46 : a907                     lda #7
0a48 : 950c             tstz3   sta zpt,x
0a4a : 0a                       asl a
0a4b : ca                       dex
0a4c : 10fa                     bpl tstz3
0a4e : a204                     ldx #4
                                set_a $aa,0
                       >            load_flag 0
0a50 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0a52 : 48              >            pha         ;use stack to load status
0a53 : a9aa            >            lda #$aa     ;precharge accu
0a55 : 28              >            plp
                        
0a56 : 640c                     stz zpt     
0a58 : 640d                     stz zpt+1
0a5a : 640e                     stz zpt+2
0a5c : 640f                     stz zpt+3
0a5e : 6410                     stz zpt+4
                                tst_a $aa,0
0a60 : 08              >            php         ;save flags
0a61 : c9aa            >            cmp #$aa     ;test result
                       >            trap_ne
0a63 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a65 : 68              >            pla         ;load status
0a66 : 48              >            pha
                       >            cmp_flag 0
0a67 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a6b : 28              >            plp         ;restore status
                        
0a6c : b50c             tstz4   lda zpt,x   ;verify zeros stored
                                trap_ne     ;non zero after STZ zp
0a6e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a70 : ca                       dex
0a71 : 10f9                     bpl tstz4
                                
0a73 : a204                     ldx #4      ;precharge test area
0a75 : a907                     lda #7
0a77 : 9d0502           tstz5   sta abst,x
0a7a : 0a                       asl a
0a7b : ca                       dex
0a7c : 10f9                     bpl tstz5
0a7e : a204                     ldx #4
                                set_a $55,$ff
                       >            load_flag $ff
0a80 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0a82 : 48              >            pha         ;use stack to load status
0a83 : a955            >            lda #$55     ;precharge accu
0a85 : 28              >            plp
                        
0a86 : 9c0502                   stz abst     
0a89 : 9c0602                   stz abst+1
0a8c : 9c0702                   stz abst+2
0a8f : 9c0802                   stz abst+3
0a92 : 9c0902                   stz abst+4
                                tst_a $55,$ff
0a95 : 08              >            php         ;save flags
0a96 : c955            >            cmp #$55     ;test result
                       >            trap_ne
0a98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a9a : 68              >            pla         ;load status
0a9b : 48              >            pha
                       >            cmp_flag $ff
0a9c : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aa0 : 28              >            plp         ;restore status
                        
0aa1 : bd0502           tstz6   lda abst,x   ;verify zeros stored
                                trap_ne     ;non zero after STZ abs
0aa4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0aa6 : ca                       dex
0aa7 : 10f8                     bpl tstz6
0aa9 : a204                     ldx #4      ;precharge test area
0aab : a907                     lda #7
0aad : 9d0502           tstz7   sta abst,x
0ab0 : 0a                       asl a
0ab1 : ca                       dex
0ab2 : 10f9                     bpl tstz7
0ab4 : a204                     ldx #4
                                set_a $aa,0
                       >            load_flag 0
0ab6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ab8 : 48              >            pha         ;use stack to load status
0ab9 : a9aa            >            lda #$aa     ;precharge accu
0abb : 28              >            plp
                        
0abc : 9c0502                   stz abst     
0abf : 9c0602                   stz abst+1
0ac2 : 9c0702                   stz abst+2
0ac5 : 9c0802                   stz abst+3
0ac8 : 9c0902                   stz abst+4
                                tst_a $aa,0
0acb : 08              >            php         ;save flags
0acc : c9aa            >            cmp #$aa     ;test result
                       >            trap_ne
0ace : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad0 : 68              >            pla         ;load status
0ad1 : 48              >            pha
                       >            cmp_flag 0
0ad2 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ad4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad6 : 28              >            plp         ;restore status
                        
0ad7 : bd0502           tstz8   lda abst,x   ;verify zeros stored
                                trap_ne     ;non zero after STZ abs
0ada : d0fe            >        bne *           ;failed not equal (non zero)
                        
0adc : ca                       dex
0add : 10f8                     bpl tstz8
                                
0adf : a204                     ldx #4      ;precharge test area
0ae1 : a907                     lda #7
0ae3 : 950c             tstz11  sta zpt,x
0ae5 : 0a                       asl a
0ae6 : ca                       dex
0ae7 : 10fa                     bpl tstz11
0ae9 : a204                     ldx #4
0aeb :                  tstz15
                                set_a $55,$ff
                       >            load_flag $ff
0aeb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0aed : 48              >            pha         ;use stack to load status
0aee : a955            >            lda #$55     ;precharge accu
0af0 : 28              >            plp
                        
0af1 : 740c                     stz zpt,x     
                                tst_a $55,$ff
0af3 : 08              >            php         ;save flags
0af4 : c955            >            cmp #$55     ;test result
                       >            trap_ne
0af6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af8 : 68              >            pla         ;load status
0af9 : 48              >            pha
                       >            cmp_flag $ff
0afa : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0afc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0afe : 28              >            plp         ;restore status
                        
0aff : ca                       dex
0b00 : 10e9                     bpl tstz15
0b02 : a204                     ldx #4
0b04 : b50c             tstz12  lda zpt,x   ;verify zeros stored
                                trap_ne     ;non zero after STZ zp
0b06 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0b08 : ca                       dex
0b09 : 10f9                     bpl tstz12
0b0b : a204                     ldx #4      ;precharge test area
0b0d : a907                     lda #7
0b0f : 950c             tstz13  sta zpt,x
0b11 : 0a                       asl a
0b12 : ca                       dex
0b13 : 10fa                     bpl tstz13
0b15 : a204                     ldx #4
0b17 :                  tstz16
                                set_a $aa,0
                       >            load_flag 0
0b17 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b19 : 48              >            pha         ;use stack to load status
0b1a : a9aa            >            lda #$aa     ;precharge accu
0b1c : 28              >            plp
                        
0b1d : 740c                     stz zpt,x
                                tst_a $aa,0
0b1f : 08              >            php         ;save flags
0b20 : c9aa            >            cmp #$aa     ;test result
                       >            trap_ne
0b22 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b24 : 68              >            pla         ;load status
0b25 : 48              >            pha
                       >            cmp_flag 0
0b26 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b2a : 28              >            plp         ;restore status
                        
0b2b : ca                       dex
0b2c : 10e9                     bpl tstz16
0b2e : a204                     ldx #4
0b30 : b50c             tstz14  lda zpt,x   ;verify zeros stored
                                trap_ne     ;non zero after STZ zp
0b32 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0b34 : ca                       dex
0b35 : 10f9                     bpl tstz14
                                
0b37 : a204                     ldx #4      ;precharge test area
0b39 : a907                     lda #7
0b3b : 9d0502           tstz21  sta abst,x
0b3e : 0a                       asl a
0b3f : ca                       dex
0b40 : 10f9                     bpl tstz21
0b42 : a204                     ldx #4
0b44 :                  tstz25
                                set_a $55,$ff
                       >            load_flag $ff
0b44 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0b46 : 48              >            pha         ;use stack to load status
0b47 : a955            >            lda #$55     ;precharge accu
0b49 : 28              >            plp
                        
0b4a : 9e0502                   stz abst,x     
                                tst_a $55,$ff
0b4d : 08              >            php         ;save flags
0b4e : c955            >            cmp #$55     ;test result
                       >            trap_ne
0b50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b52 : 68              >            pla         ;load status
0b53 : 48              >            pha
                       >            cmp_flag $ff
0b54 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b58 : 28              >            plp         ;restore status
                        
0b59 : ca                       dex
0b5a : 10e8                     bpl tstz25
0b5c : a204                     ldx #4
0b5e : bd0502           tstz22  lda abst,x   ;verify zeros stored
                                trap_ne     ;non zero after STZ zp
0b61 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0b63 : ca                       dex
0b64 : 10f8                     bpl tstz22
0b66 : a204                     ldx #4      ;precharge test area
0b68 : a907                     lda #7
0b6a : 9d0502           tstz23  sta abst,x
0b6d : 0a                       asl a
0b6e : ca                       dex
0b6f : 10f9                     bpl tstz23
0b71 : a204                     ldx #4
0b73 :                  tstz26
                                set_a $aa,0
                       >            load_flag 0
0b73 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b75 : 48              >            pha         ;use stack to load status
0b76 : a9aa            >            lda #$aa     ;precharge accu
0b78 : 28              >            plp
                        
0b79 : 9e0502                   stz abst,x
                                tst_a $aa,0
0b7c : 08              >            php         ;save flags
0b7d : c9aa            >            cmp #$aa     ;test result
                       >            trap_ne
0b7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b81 : 68              >            pla         ;load status
0b82 : 48              >            pha
                       >            cmp_flag 0
0b83 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b87 : 28              >            plp         ;restore status
                        
0b88 : ca                       dex
0b89 : 10e8                     bpl tstz26
0b8b : a204                     ldx #4
0b8d : bd0502           tstz24  lda abst,x   ;verify zeros stored
                                trap_ne     ;non zero after STZ zp
0b90 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0b92 : ca                       dex
0b93 : 10f8                     bpl tstz24
                                
0b95 : c07b                     cpy #123
                                trap_ne     ;y altered during test 
0b97 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0b99 : ba                       tsx
0b9a : e0ff                     cpx #$ff
                                trap_ne     ;sp push/pop mismatch
0b9c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0b9e : ad0202          >            lda test_case   ;previous test
0ba1 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0ba3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
0ba5 : a90c            >            lda #test_num   ;*** next tests' number
0ba7 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing BIT - zp,x / abs,x / #
0baa : a042                     ldy #$42
0bac : a203                     ldx #3
                                set_a $ff,0
                       >            load_flag 0
0bae : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0bb0 : 48              >            pha         ;use stack to load status
0bb1 : a9ff            >            lda #$ff     ;precharge accu
0bb3 : 28              >            plp
                        
0bb4 : 3413                     bit zp1,x   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
0bb6 : 08              >            php         ;save flags
0bb7 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0bb9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bbb : 68              >            pla         ;load status
0bbc : 48              >            pha
                       >            cmp_flag fz 
0bbd : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bbf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc1 : 28              >            plp         ;restore status
                        
0bc2 : ca                       dex
                                set_a 1,0
                       >            load_flag 0
0bc3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0bc5 : 48              >            pha         ;use stack to load status
0bc6 : a901            >            lda #1     ;precharge accu
0bc8 : 28              >            plp
                        
0bc9 : 3413                     bit zp1,x   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
0bcb : 08              >            php         ;save flags
0bcc : c901            >            cmp #1     ;test result
                       >            trap_ne
0bce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd0 : 68              >            pla         ;load status
0bd1 : 48              >            pha
                       >            cmp_flag fv
0bd2 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bd4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd6 : 28              >            plp         ;restore status
                        
0bd7 : ca                       dex
                                set_a 1,0
                       >            load_flag 0
0bd8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0bda : 48              >            pha         ;use stack to load status
0bdb : a901            >            lda #1     ;precharge accu
0bdd : 28              >            plp
                        
0bde : 3413                     bit zp1,x   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
0be0 : 08              >            php         ;save flags
0be1 : c901            >            cmp #1     ;test result
                       >            trap_ne
0be3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be5 : 68              >            pla         ;load status
0be6 : 48              >            pha
                       >            cmp_flag fnz
0be7 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0be9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0beb : 28              >            plp         ;restore status
                        
0bec : ca                       dex
                                set_a 1,0
                       >            load_flag 0
0bed : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0bef : 48              >            pha         ;use stack to load status
0bf0 : a901            >            lda #1     ;precharge accu
0bf2 : 28              >            plp
                        
0bf3 : 3413                     bit zp1,x   ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
0bf5 : 08              >            php         ;save flags
0bf6 : c901            >            cmp #1     ;test result
                       >            trap_ne
0bf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bfa : 68              >            pla         ;load status
0bfb : 48              >            pha
                       >            cmp_flag fnv
0bfc : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bfe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c00 : 28              >            plp         ;restore status
                        
                                
                                set_a 1,$ff
                       >            load_flag $ff
0c01 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c03 : 48              >            pha         ;use stack to load status
0c04 : a901            >            lda #1     ;precharge accu
0c06 : 28              >            plp
                        
0c07 : 3413                     bit zp1,x   ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
0c09 : 08              >            php         ;save flags
0c0a : c901            >            cmp #1     ;test result
                       >            trap_ne
0c0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c0e : 68              >            pla         ;load status
0c0f : 48              >            pha
                       >            cmp_flag ~fz
0c10 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c14 : 28              >            plp         ;restore status
                        
0c15 : e8                       inx
                                set_a 1,$ff
                       >            load_flag $ff
0c16 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c18 : 48              >            pha         ;use stack to load status
0c19 : a901            >            lda #1     ;precharge accu
0c1b : 28              >            plp
                        
0c1c : 3413                     bit zp1,x   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
0c1e : 08              >            php         ;save flags
0c1f : c901            >            cmp #1     ;test result
                       >            trap_ne
0c21 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c23 : 68              >            pla         ;load status
0c24 : 48              >            pha
                       >            cmp_flag ~fv
0c25 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c27 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c29 : 28              >            plp         ;restore status
                        
0c2a : e8                       inx
                                set_a 1,$ff
                       >            load_flag $ff
0c2b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c2d : 48              >            pha         ;use stack to load status
0c2e : a901            >            lda #1     ;precharge accu
0c30 : 28              >            plp
                        
0c31 : 3413                     bit zp1,x   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
0c33 : 08              >            php         ;save flags
0c34 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c36 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c38 : 68              >            pla         ;load status
0c39 : 48              >            pha
                       >            cmp_flag ~fnz
0c3a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c3c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c3e : 28              >            plp         ;restore status
                        
0c3f : e8                       inx
                                set_a $ff,$ff
                       >            load_flag $ff
0c40 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c42 : 48              >            pha         ;use stack to load status
0c43 : a9ff            >            lda #$ff     ;precharge accu
0c45 : 28              >            plp
                        
0c46 : 3413                     bit zp1,x   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
0c48 : 08              >            php         ;save flags
0c49 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c4b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c4d : 68              >            pla         ;load status
0c4e : 48              >            pha
                       >            cmp_flag ~fnv 
0c4f : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c51 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c53 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
0c54 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c56 : 48              >            pha         ;use stack to load status
0c57 : a9ff            >            lda #$ff     ;precharge accu
0c59 : 28              >            plp
                        
0c5a : 3c1002                   bit abs1,x  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
0c5d : 08              >            php         ;save flags
0c5e : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c62 : 68              >            pla         ;load status
0c63 : 48              >            pha
                       >            cmp_flag fz 
0c64 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c68 : 28              >            plp         ;restore status
                        
0c69 : ca                       dex
                                set_a 1,0
                       >            load_flag 0
0c6a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c6c : 48              >            pha         ;use stack to load status
0c6d : a901            >            lda #1     ;precharge accu
0c6f : 28              >            plp
                        
0c70 : 3c1002                   bit abs1,x  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
0c73 : 08              >            php         ;save flags
0c74 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c78 : 68              >            pla         ;load status
0c79 : 48              >            pha
                       >            cmp_flag fv
0c7a : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c7c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c7e : 28              >            plp         ;restore status
                        
0c7f : ca                       dex
                                set_a 1,0
                       >            load_flag 0
0c80 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c82 : 48              >            pha         ;use stack to load status
0c83 : a901            >            lda #1     ;precharge accu
0c85 : 28              >            plp
                        
0c86 : 3c1002                   bit abs1,x  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
0c89 : 08              >            php         ;save flags
0c8a : c901            >            cmp #1     ;test result
                       >            trap_ne
0c8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c8e : 68              >            pla         ;load status
0c8f : 48              >            pha
                       >            cmp_flag fnz
0c90 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c94 : 28              >            plp         ;restore status
                        
0c95 : ca                       dex
                                set_a 1,0
                       >            load_flag 0
0c96 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c98 : 48              >            pha         ;use stack to load status
0c99 : a901            >            lda #1     ;precharge accu
0c9b : 28              >            plp
                        
0c9c : 3c1002                   bit abs1,x  ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
0c9f : 08              >            php         ;save flags
0ca0 : c901            >            cmp #1     ;test result
                       >            trap_ne
0ca2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca4 : 68              >            pla         ;load status
0ca5 : 48              >            pha
                       >            cmp_flag fnv
0ca6 : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ca8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0caa : 28              >            plp         ;restore status
                        
                                
                                set_a 1,$ff
                       >            load_flag $ff
0cab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0cad : 48              >            pha         ;use stack to load status
0cae : a901            >            lda #1     ;precharge accu
0cb0 : 28              >            plp
                        
0cb1 : 3c1002                   bit abs1,x  ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
0cb4 : 08              >            php         ;save flags
0cb5 : c901            >            cmp #1     ;test result
                       >            trap_ne
0cb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb9 : 68              >            pla         ;load status
0cba : 48              >            pha
                       >            cmp_flag ~fz
0cbb : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cbd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cbf : 28              >            plp         ;restore status
                        
0cc0 : e8                       inx
                                set_a 1,$ff
                       >            load_flag $ff
0cc1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0cc3 : 48              >            pha         ;use stack to load status
0cc4 : a901            >            lda #1     ;precharge accu
0cc6 : 28              >            plp
                        
0cc7 : 3c1002                   bit abs1,x  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
0cca : 08              >            php         ;save flags
0ccb : c901            >            cmp #1     ;test result
                       >            trap_ne
0ccd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ccf : 68              >            pla         ;load status
0cd0 : 48              >            pha
                       >            cmp_flag ~fv
0cd1 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cd3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd5 : 28              >            plp         ;restore status
                        
0cd6 : e8                       inx
                                set_a 1,$ff
                       >            load_flag $ff
0cd7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0cd9 : 48              >            pha         ;use stack to load status
0cda : a901            >            lda #1     ;precharge accu
0cdc : 28              >            plp
                        
0cdd : 3c1002                   bit abs1,x  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
0ce0 : 08              >            php         ;save flags
0ce1 : c901            >            cmp #1     ;test result
                       >            trap_ne
0ce3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce5 : 68              >            pla         ;load status
0ce6 : 48              >            pha
                       >            cmp_flag ~fnz
0ce7 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ce9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ceb : 28              >            plp         ;restore status
                        
0cec : e8                       inx
                                set_a $ff,$ff
                       >            load_flag $ff
0ced : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0cef : 48              >            pha         ;use stack to load status
0cf0 : a9ff            >            lda #$ff     ;precharge accu
0cf2 : 28              >            plp
                        
0cf3 : 3c1002                   bit abs1,x  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
0cf6 : 08              >            php         ;save flags
0cf7 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0cf9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cfb : 68              >            pla         ;load status
0cfc : 48              >            pha
                       >            cmp_flag ~fnv 
0cfd : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d01 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
0d02 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d04 : 48              >            pha         ;use stack to load status
0d05 : a9ff            >            lda #$ff     ;precharge accu
0d07 : 28              >            plp
                        
0d08 : 8900                     bit #$00    ;00 - should set Z
                                tst_a $ff,fz 
0d0a : 08              >            php         ;save flags
0d0b : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0d0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d0f : 68              >            pla         ;load status
0d10 : 48              >            pha
                       >            cmp_flag fz 
0d11 : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d13 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d15 : 28              >            plp         ;restore status
                        
0d16 : ca                       dex
                                set_a 1,0
                       >            load_flag 0
0d17 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d19 : 48              >            pha         ;use stack to load status
0d1a : a901            >            lda #1     ;precharge accu
0d1c : 28              >            plp
                        
0d1d : 8941                     bit #$41    ;41 - should clear Z
                                tst_a 1,0
0d1f : 08              >            php         ;save flags
0d20 : c901            >            cmp #1     ;test result
                       >            trap_ne
0d22 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d24 : 68              >            pla         ;load status
0d25 : 48              >            pha
                       >            cmp_flag 0
0d26 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d2a : 28              >            plp         ;restore status
                        
                        ; *** DEBUG INFO ***
                        ; if it fails the previous test and your BIT # has set the V flag
                        ; see http://forum.6502.org/viewtopic.php?f=2&t=2241&p=27243#p27239
                        ; why it shouldn't alter N or V flags on a BIT #
0d2b : ca                       dex
                                set_a 1,0
                       >            load_flag 0
0d2c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d2e : 48              >            pha         ;use stack to load status
0d2f : a901            >            lda #1     ;precharge accu
0d31 : 28              >            plp
                        
0d32 : 8982                     bit #$82    ;82 - should set Z
                                tst_a 1,fz
0d34 : 08              >            php         ;save flags
0d35 : c901            >            cmp #1     ;test result
                       >            trap_ne
0d37 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d39 : 68              >            pla         ;load status
0d3a : 48              >            pha
                       >            cmp_flag fz
0d3b : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d3f : 28              >            plp         ;restore status
                        
0d40 : ca                       dex
                                set_a 1,0
                       >            load_flag 0
0d41 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0d43 : 48              >            pha         ;use stack to load status
0d44 : a901            >            lda #1     ;precharge accu
0d46 : 28              >            plp
                        
0d47 : 89c3                     bit #$c3    ;c3 - should clear Z
                                tst_a 1,0
0d49 : 08              >            php         ;save flags
0d4a : c901            >            cmp #1     ;test result
                       >            trap_ne
0d4c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d4e : 68              >            pla         ;load status
0d4f : 48              >            pha
                       >            cmp_flag 0
0d50 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d52 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d54 : 28              >            plp         ;restore status
                        
                                
                                set_a 1,$ff
                       >            load_flag $ff
0d55 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d57 : 48              >            pha         ;use stack to load status
0d58 : a901            >            lda #1     ;precharge accu
0d5a : 28              >            plp
                        
0d5b : 89c3                     bit #$c3    ;c3 - clear Z
                                tst_a 1,~fz
0d5d : 08              >            php         ;save flags
0d5e : c901            >            cmp #1     ;test result
                       >            trap_ne
0d60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d62 : 68              >            pla         ;load status
0d63 : 48              >            pha
                       >            cmp_flag ~fz
0d64 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d68 : 28              >            plp         ;restore status
                        
0d69 : e8                       inx
                                set_a 1,$ff
                       >            load_flag $ff
0d6a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d6c : 48              >            pha         ;use stack to load status
0d6d : a901            >            lda #1     ;precharge accu
0d6f : 28              >            plp
                        
0d70 : 8982                     bit #$82    ;82 - should set Z
                                tst_a 1,$ff
0d72 : 08              >            php         ;save flags
0d73 : c901            >            cmp #1     ;test result
                       >            trap_ne
0d75 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d77 : 68              >            pla         ;load status
0d78 : 48              >            pha
                       >            cmp_flag $ff
0d79 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d7d : 28              >            plp         ;restore status
                        
0d7e : e8                       inx
                                set_a 1,$ff
                       >            load_flag $ff
0d7f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d81 : 48              >            pha         ;use stack to load status
0d82 : a901            >            lda #1     ;precharge accu
0d84 : 28              >            plp
                        
0d85 : 8941                     bit #$41    ;41 - should clear Z
                                tst_a 1,~fz
0d87 : 08              >            php         ;save flags
0d88 : c901            >            cmp #1     ;test result
                       >            trap_ne
0d8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d8c : 68              >            pla         ;load status
0d8d : 48              >            pha
                       >            cmp_flag ~fz
0d8e : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d92 : 28              >            plp         ;restore status
                        
0d93 : e8                       inx
                                set_a $ff,$ff
                       >            load_flag $ff
0d94 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0d96 : 48              >            pha         ;use stack to load status
0d97 : a9ff            >            lda #$ff     ;precharge accu
0d99 : 28              >            plp
                        
0d9a : 8900                     bit #$00   ;00 - should set Z
                                tst_a $ff,$ff
0d9c : 08              >            php         ;save flags
0d9d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0d9f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0da1 : 68              >            pla         ;load status
0da2 : 48              >            pha
                       >            cmp_flag $ff
0da3 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0da5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0da7 : 28              >            plp         ;restore status
                        
                                
0da8 : e003                     cpx #3
                                trap_ne     ;x altered during test
0daa : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dac : c042                     cpy #$42
                                trap_ne     ;y altered during test 
0dae : d0fe            >        bne *           ;failed not equal (non zero)
                        
0db0 : ba                       tsx
0db1 : e0ff                     cpx #$ff
                                trap_ne     ;sp push/pop mismatch
0db3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0db5 : ad0202          >            lda test_case   ;previous test
0db8 : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0dba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0dbc : a90d            >            lda #test_num   ;*** next tests' number
0dbe : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing TRB, TSB - zp / abs
                        
                        trbt    macro       ;\1 = memory, \2 = flags   
                                sty \1
                                load_flag \2
                                pha
                                lda zpt+1
                                plp
                                trb \1
                                php
                                cmp zpt+1
                                trap_ne     ;accu was changed
                                pla
                                pha
                                ora #fz     ;mask Z
                                cmp_flag \2|fz
                                trap_ne     ;flags changed except Z
                                pla
                                and #fz
                                cmp zpt+2
                                trap_ne     ;Z flag invalid
                                lda zpt+3
                                cmp zpt
                                trap_ne     ;altered bits in memory wrong       
                                endm
                        
                        tsbt    macro       ;\1 = memory, \2 = flags   
                                sty \1
                                load_flag \2
                                pha
                                lda zpt+1
                                plp
                                tsb \1
                                php
                                cmp zpt+1
                                trap_ne     ;accu was changed
                                pla
                                pha
                                ora #fz     ;mask Z
                                cmp_flag \2|fz
                                trap_ne     ;flags changed except Z
                                pla
                                and #fz
                                cmp zpt+2
                                trap_ne     ;Z flag invalid
                                lda zpt+4
                                cmp zpt
                                trap_ne     ;altered bits in memory wrong        
                                endm
                        
0dc1 : a2c0                     ldx #$c0
0dc3 : a000                     ldy #0      ;op1 - memory save
                                ;   zpt     ;op1 - memory modifiable
0dc5 : 640d                     stz zpt+1   ;op2 - accu
                                ;   zpt+2   ;and flags
                                ;   zpt+3   ;memory after reset
                                ;   zpt+4   ;memory after set
                                
0dc7 : 98               tbt1    tya
0dc8 : 250d                     and zpt+1   ;set Z by anding the 2 operands
0dca : 08                       php
0dcb : 68                       pla
0dcc : 2902                     and #fz     ;mask Z
0dce : 850e                     sta zpt+2
0dd0 : 98                       tya         ;reset op1 bits by op2
0dd1 : 49ff                     eor #$ff
0dd3 : 050d                     ora zpt+1
0dd5 : 49ff                     eor #$ff
0dd7 : 850f                     sta zpt+3
0dd9 : 98                       tya         ;set op1 bits by op2
0dda : 050d                     ora zpt+1
0ddc : 8510                     sta zpt+4
                        
                                trbt zpt,$ff
0dde : 840c            >        sty zpt
                       >        load_flag $ff
0de0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0de2 : 48              >        pha
0de3 : a50d            >        lda zpt+1
0de5 : 28              >        plp
0de6 : 140c            >        trb zpt
0de8 : 08              >        php
0de9 : c50d            >        cmp zpt+1
                       >        trap_ne     ;accu was changed
0deb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ded : 68              >        pla
0dee : 48              >        pha
0def : 0902            >        ora #fz     ;mask Z
                       >        cmp_flag $ff|fz
0df1 : c9ff            >            cmp #($ff|fz|fao)&m8    ;expected flags + always on bits
                       >
                       >        trap_ne     ;flags changed except Z
0df3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0df5 : 68              >        pla
0df6 : 2902            >        and #fz
0df8 : c50e            >        cmp zpt+2
                       >        trap_ne     ;Z flag invalid
0dfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0dfc : a50f            >        lda zpt+3
0dfe : c50c            >        cmp zpt
                       >        trap_ne     ;altered bits in memory wrong       
0e00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
                                trbt abst,$ff
0e02 : 8c0502          >        sty abst
                       >        load_flag $ff
0e05 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e07 : 48              >        pha
0e08 : a50d            >        lda zpt+1
0e0a : 28              >        plp
0e0b : 1c0502          >        trb abst
0e0e : 08              >        php
0e0f : c50d            >        cmp zpt+1
                       >        trap_ne     ;accu was changed
0e11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e13 : 68              >        pla
0e14 : 48              >        pha
0e15 : 0902            >        ora #fz     ;mask Z
                       >        cmp_flag $ff|fz
0e17 : c9ff            >            cmp #($ff|fz|fao)&m8    ;expected flags + always on bits
                       >
                       >        trap_ne     ;flags changed except Z
0e19 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e1b : 68              >        pla
0e1c : 2902            >        and #fz
0e1e : c50e            >        cmp zpt+2
                       >        trap_ne     ;Z flag invalid
0e20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e22 : a50f            >        lda zpt+3
0e24 : c50c            >        cmp zpt
                       >        trap_ne     ;altered bits in memory wrong       
0e26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
                                trbt zpt,0
0e28 : 840c            >        sty zpt
                       >        load_flag 0
0e2a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e2c : 48              >        pha
0e2d : a50d            >        lda zpt+1
0e2f : 28              >        plp
0e30 : 140c            >        trb zpt
0e32 : 08              >        php
0e33 : c50d            >        cmp zpt+1
                       >        trap_ne     ;accu was changed
0e35 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e37 : 68              >        pla
0e38 : 48              >        pha
0e39 : 0902            >        ora #fz     ;mask Z
                       >        cmp_flag 0|fz
0e3b : c932            >            cmp #(0|fz|fao)&m8    ;expected flags + always on bits
                       >
                       >        trap_ne     ;flags changed except Z
0e3d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e3f : 68              >        pla
0e40 : 2902            >        and #fz
0e42 : c50e            >        cmp zpt+2
                       >        trap_ne     ;Z flag invalid
0e44 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e46 : a50f            >        lda zpt+3
0e48 : c50c            >        cmp zpt
                       >        trap_ne     ;altered bits in memory wrong       
0e4a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
                                trbt abst,0
0e4c : 8c0502          >        sty abst
                       >        load_flag 0
0e4f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e51 : 48              >        pha
0e52 : a50d            >        lda zpt+1
0e54 : 28              >        plp
0e55 : 1c0502          >        trb abst
0e58 : 08              >        php
0e59 : c50d            >        cmp zpt+1
                       >        trap_ne     ;accu was changed
0e5b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e5d : 68              >        pla
0e5e : 48              >        pha
0e5f : 0902            >        ora #fz     ;mask Z
                       >        cmp_flag 0|fz
0e61 : c932            >            cmp #(0|fz|fao)&m8    ;expected flags + always on bits
                       >
                       >        trap_ne     ;flags changed except Z
0e63 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e65 : 68              >        pla
0e66 : 2902            >        and #fz
0e68 : c50e            >        cmp zpt+2
                       >        trap_ne     ;Z flag invalid
0e6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e6c : a50f            >        lda zpt+3
0e6e : c50c            >        cmp zpt
                       >        trap_ne     ;altered bits in memory wrong       
0e70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
                                tsbt zpt,$ff
0e72 : 840c            >        sty zpt
                       >        load_flag $ff
0e74 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e76 : 48              >        pha
0e77 : a50d            >        lda zpt+1
0e79 : 28              >        plp
0e7a : 040c            >        tsb zpt
0e7c : 08              >        php
0e7d : c50d            >        cmp zpt+1
                       >        trap_ne     ;accu was changed
0e7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e81 : 68              >        pla
0e82 : 48              >        pha
0e83 : 0902            >        ora #fz     ;mask Z
                       >        cmp_flag $ff|fz
0e85 : c9ff            >            cmp #($ff|fz|fao)&m8    ;expected flags + always on bits
                       >
                       >        trap_ne     ;flags changed except Z
0e87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e89 : 68              >        pla
0e8a : 2902            >        and #fz
0e8c : c50e            >        cmp zpt+2
                       >        trap_ne     ;Z flag invalid
0e8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e90 : a510            >        lda zpt+4
0e92 : c50c            >        cmp zpt
                       >        trap_ne     ;altered bits in memory wrong        
0e94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
                                tsbt abst,$ff
0e96 : 8c0502          >        sty abst
                       >        load_flag $ff
0e99 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e9b : 48              >        pha
0e9c : a50d            >        lda zpt+1
0e9e : 28              >        plp
0e9f : 0c0502          >        tsb abst
0ea2 : 08              >        php
0ea3 : c50d            >        cmp zpt+1
                       >        trap_ne     ;accu was changed
0ea5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ea7 : 68              >        pla
0ea8 : 48              >        pha
0ea9 : 0902            >        ora #fz     ;mask Z
                       >        cmp_flag $ff|fz
0eab : c9ff            >            cmp #($ff|fz|fao)&m8    ;expected flags + always on bits
                       >
                       >        trap_ne     ;flags changed except Z
0ead : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0eaf : 68              >        pla
0eb0 : 2902            >        and #fz
0eb2 : c50e            >        cmp zpt+2
                       >        trap_ne     ;Z flag invalid
0eb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0eb6 : a510            >        lda zpt+4
0eb8 : c50c            >        cmp zpt
                       >        trap_ne     ;altered bits in memory wrong        
0eba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
                                tsbt zpt,0
0ebc : 840c            >        sty zpt
                       >        load_flag 0
0ebe : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ec0 : 48              >        pha
0ec1 : a50d            >        lda zpt+1
0ec3 : 28              >        plp
0ec4 : 040c            >        tsb zpt
0ec6 : 08              >        php
0ec7 : c50d            >        cmp zpt+1
                       >        trap_ne     ;accu was changed
0ec9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ecb : 68              >        pla
0ecc : 48              >        pha
0ecd : 0902            >        ora #fz     ;mask Z
                       >        cmp_flag 0|fz
0ecf : c932            >            cmp #(0|fz|fao)&m8    ;expected flags + always on bits
                       >
                       >        trap_ne     ;flags changed except Z
0ed1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ed3 : 68              >        pla
0ed4 : 2902            >        and #fz
0ed6 : c50e            >        cmp zpt+2
                       >        trap_ne     ;Z flag invalid
0ed8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0eda : a510            >        lda zpt+4
0edc : c50c            >        cmp zpt
                       >        trap_ne     ;altered bits in memory wrong        
0ede : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
                                tsbt abst,0
0ee0 : 8c0502          >        sty abst
                       >        load_flag 0
0ee3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ee5 : 48              >        pha
0ee6 : a50d            >        lda zpt+1
0ee8 : 28              >        plp
0ee9 : 0c0502          >        tsb abst
0eec : 08              >        php
0eed : c50d            >        cmp zpt+1
                       >        trap_ne     ;accu was changed
0eef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ef1 : 68              >        pla
0ef2 : 48              >        pha
0ef3 : 0902            >        ora #fz     ;mask Z
                       >        cmp_flag 0|fz
0ef5 : c932            >            cmp #(0|fz|fao)&m8    ;expected flags + always on bits
                       >
                       >        trap_ne     ;flags changed except Z
0ef7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ef9 : 68              >        pla
0efa : 2902            >        and #fz
0efc : c50e            >        cmp zpt+2
                       >        trap_ne     ;Z flag invalid
0efe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f00 : a510            >        lda zpt+4
0f02 : c50c            >        cmp zpt
                       >        trap_ne     ;altered bits in memory wrong        
0f04 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
                                
0f06 : c8                       iny         ;iterate op1
0f07 : d004                     bne tbt3
0f09 : e60d                     inc zpt+1   ;iterate op2
0f0b : f003                     beq tbt2
0f0d : 4cc70d           tbt3    jmp tbt1        
0f10 :                  tbt2
0f10 : e0c0                     cpx #$c0
                                trap_ne     ;x altered during test
0f12 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f14 : ba                       tsx
0f15 : e0ff                     cpx #$ff
                                trap_ne     ;sp push/pop mismatch
0f17 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test    
0f19 : ad0202          >            lda test_case   ;previous test
0f1c : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0f1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0f20 : a90e            >            lda #test_num   ;*** next tests' number
0f22 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if rkwl_wdc_op = 1
                        ; testing RMB, SMB - zp
                        rmbt    macro       ;\1 = bitnum
                                lda #$ff
                                sta zpt
                                set_a $a5,0
                                rmb \1,zpt
                                tst_a $a5,0
                                lda zpt
                                cmp #$ff-(1<<\1)
                                trap_ne     ;wrong bits set or cleared
                                lda #1<<\1
                                sta zpt
                                set_a $5a,$ff
                                rmb \1,zpt
                                tst_a $5a,$ff
                                lda zpt
                                trap_ne     ;wrong bits set or cleared
                                endm
                        smbt    macro       ;\1 = bitnum
                                lda #$ff-(1<<\1)
                                sta zpt
                                set_a $a5,0
                                smb \1,zpt
                                tst_a $a5,0
                                lda zpt
                                cmp #$ff
                                trap_ne     ;wrong bits set or cleared
                                lda #0
                                sta zpt
                                set_a $5a,$ff
                                smb \1,zpt
                                tst_a $5a,$ff
                                lda zpt
                                cmp #1<<\1
                                trap_ne     ;wrong bits set or cleared
                                endm
                        
                                ldx #$ba    ;protect x & y
                                ldy #$d0
                                rmbt 0
                                rmbt 1
                                rmbt 2
                                rmbt 3
                                rmbt 4
                                rmbt 5
                                rmbt 6
                                rmbt 7
                                smbt 0
                                smbt 1
                                smbt 2
                                smbt 3
                                smbt 4
                                smbt 5
                                smbt 6
                                smbt 7
                                cpx #$ba
                                trap_ne     ;x altered during test
                                cpy #$d0
                                trap_ne     ;y altered during test
                                tsx
                                cpx #$ff
                                trap_ne     ;sp push/pop mismatch
                                next_test
                            endif        
                                 
                        ; testing CMP - (zp)         
0f25 : a2de                     ldx #$de    ;protect x & y
0f27 : a0ad                     ldy #$ad
                                set_a $80,0
                       >            load_flag 0
0f29 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f2b : 48              >            pha         ;use stack to load status
0f2c : a980            >            lda #$80     ;precharge accu
0f2e : 28              >            plp
                        
0f2f : d22c                     cmp (ind1+8)
                                tst_a $80,fc
0f31 : 08              >            php         ;save flags
0f32 : c980            >            cmp #$80     ;test result
                       >            trap_ne
0f34 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f36 : 68              >            pla         ;load status
0f37 : 48              >            pha
                       >            cmp_flag fc
0f38 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f3c : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
0f3d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f3f : 48              >            pha         ;use stack to load status
0f40 : a97f            >            lda #$7f     ;precharge accu
0f42 : 28              >            plp
                        
0f43 : d22c                     cmp (ind1+8)
                                tst_a $7f,fzc
0f45 : 08              >            php         ;save flags
0f46 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
0f48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f4a : 68              >            pla         ;load status
0f4b : 48              >            pha
                       >            cmp_flag fzc
0f4c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f50 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
0f51 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f53 : 48              >            pha         ;use stack to load status
0f54 : a97e            >            lda #$7e     ;precharge accu
0f56 : 28              >            plp
                        
0f57 : d22c                     cmp (ind1+8)
                                tst_a $7e,fn
0f59 : 08              >            php         ;save flags
0f5a : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
0f5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f5e : 68              >            pla         ;load status
0f5f : 48              >            pha
                       >            cmp_flag fn
0f60 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f62 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f64 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
0f65 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f67 : 48              >            pha         ;use stack to load status
0f68 : a980            >            lda #$80     ;precharge accu
0f6a : 28              >            plp
                        
0f6b : d22c                     cmp (ind1+8)
                                tst_a $80,~fnz
0f6d : 08              >            php         ;save flags
0f6e : c980            >            cmp #$80     ;test result
                       >            trap_ne
0f70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f72 : 68              >            pla         ;load status
0f73 : 48              >            pha
                       >            cmp_flag ~fnz
0f74 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f78 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
0f79 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f7b : 48              >            pha         ;use stack to load status
0f7c : a97f            >            lda #$7f     ;precharge accu
0f7e : 28              >            plp
                        
0f7f : d22c                     cmp (ind1+8)
                                tst_a $7f,~fn
0f81 : 08              >            php         ;save flags
0f82 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
0f84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f86 : 68              >            pla         ;load status
0f87 : 48              >            pha
                       >            cmp_flag ~fn
0f88 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f8c : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
0f8d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f8f : 48              >            pha         ;use stack to load status
0f90 : a97e            >            lda #$7e     ;precharge accu
0f92 : 28              >            plp
                        
0f93 : d22c                     cmp (ind1+8)
                                tst_a $7e,~fzc
0f95 : 08              >            php         ;save flags
0f96 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
0f98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0f9a : 68              >            pla         ;load status
0f9b : 48              >            pha
                       >            cmp_flag ~fzc
0f9c : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0f9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fa0 : 28              >            plp         ;restore status
                        
0fa1 : e0de                     cpx #$de
                                trap_ne     ;x altered during test
0fa3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fa5 : c0ad                     cpy #$ad
                                trap_ne     ;y altered during test 
0fa7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fa9 : ba                       tsx
0faa : e0ff                     cpx #$ff
                                trap_ne     ;sp push/pop mismatch
0fac : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0fae : ad0202          >            lda test_case   ;previous test
0fb1 : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0fb3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0fb5 : a90f            >            lda #test_num   ;*** next tests' number
0fb7 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA (zp)
0fba : a242                     ldx #$42    ;protect x & y
                        
0fbc : a000                     ldy #0      ;AND
0fbe : a53a                     lda indAN   ;set indirect address
0fc0 : 850c                     sta zpt
0fc2 : a53b                     lda indAN+1
0fc4 : 850d                     sta zpt+1
0fc6 :                  tand1
                                set_ay  absANa,0
                       >            load_flag 0
0fc6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0fc8 : 48              >            pha         ;use stack to load status
0fc9 : b95302          >            lda absANa,y    ;precharge accu
0fcc : 28              >            plp
                        
0fcd : 320c                     and (zpt)
                                tst_ay  absrlo,absflo,0
0fcf : 08              >            php         ;save flags
0fd0 : d95b02          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
0fd3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0fd5 : 68              >            pla         ;load status
                       >            eor_flag 0
0fd6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
0fd8 : d95f02          >            cmp absflo,y    ;test flags
                       >            trap_ne
0fdb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
0fdd : e60c                     inc zpt
0fdf : c8                       iny
0fe0 : c004                     cpy #4
0fe2 : d0e2                     bne tand1
0fe4 : 88                       dey
0fe5 : c60c                     dec zpt
0fe7 :                  tand2
                                set_ay  absANa,$ff
                       >            load_flag $ff
0fe7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0fe9 : 48              >            pha         ;use stack to load status
0fea : b95302          >            lda absANa,y    ;precharge accu
0fed : 28              >            plp
                        
0fee : 320c                     and (zpt)
                                tst_ay  absrlo,absflo,$ff-fnz
0ff0 : 08              >            php         ;save flags
0ff1 : d95b02          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
0ff4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ff6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
0ff7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
0ff9 : d95f02          >            cmp absflo,y    ;test flags
                       >            trap_ne
0ffc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
0ffe : c60c                     dec zpt
1000 : 88                       dey
1001 : 10e4                     bpl tand2
                        
1003 : a000                     ldy #0      ;EOR
1005 : a542                     lda indEO   ;set indirect address
1007 : 850c                     sta zpt
1009 : a543                     lda indEO+1
100b : 850d                     sta zpt+1
100d :                  teor1
                                set_ay  absEOa,0
                       >            load_flag 0
100d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
100f : 48              >            pha         ;use stack to load status
1010 : b95702          >            lda absEOa,y    ;precharge accu
1013 : 28              >            plp
                        
1014 : 520c                     eor (zpt)
                                tst_ay  absrlo,absflo,0
1016 : 08              >            php         ;save flags
1017 : d95b02          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
101a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
101c : 68              >            pla         ;load status
                       >            eor_flag 0
101d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
101f : d95f02          >            cmp absflo,y    ;test flags
                       >            trap_ne
1022 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
1024 : e60c                     inc zpt
1026 : c8                       iny
1027 : c004                     cpy #4
1029 : d0e2                     bne teor1
102b : 88                       dey
102c : c60c                     dec zpt
102e :                  teor2
                                set_ay  absEOa,$ff
                       >            load_flag $ff
102e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1030 : 48              >            pha         ;use stack to load status
1031 : b95702          >            lda absEOa,y    ;precharge accu
1034 : 28              >            plp
                        
1035 : 520c                     eor (zpt)
                                tst_ay  absrlo,absflo,$ff-fnz
1037 : 08              >            php         ;save flags
1038 : d95b02          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
103b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
103d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
103e : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
1040 : d95f02          >            cmp absflo,y    ;test flags
                       >            trap_ne
1043 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
1045 : c60c                     dec zpt
1047 : 88                       dey
1048 : 10e4                     bpl teor2
                        
104a : a000                     ldy #0      ;ORA
104c : a54a                     lda indOR   ;set indirect address
104e : 850c                     sta zpt
1050 : a54b                     lda indOR+1
1052 : 850d                     sta zpt+1
1054 :                  tora1
                                set_ay  absORa,0
                       >            load_flag 0
1054 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1056 : 48              >            pha         ;use stack to load status
1057 : b94f02          >            lda absORa,y    ;precharge accu
105a : 28              >            plp
                        
105b : 120c                     ora (zpt)
                                tst_ay  absrlo,absflo,0
105d : 08              >            php         ;save flags
105e : d95b02          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
1061 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1063 : 68              >            pla         ;load status
                       >            eor_flag 0
1064 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
1066 : d95f02          >            cmp absflo,y    ;test flags
                       >            trap_ne
1069 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
106b : e60c                     inc zpt
106d : c8                       iny
106e : c004                     cpy #4
1070 : d0e2                     bne tora1
1072 : 88                       dey
1073 : c60c                     dec zpt
1075 :                  tora2
                                set_ay  absORa,$ff
                       >            load_flag $ff
1075 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1077 : 48              >            pha         ;use stack to load status
1078 : b94f02          >            lda absORa,y    ;precharge accu
107b : 28              >            plp
                        
107c : 120c                     ora (zpt)
                                tst_ay  absrlo,absflo,$ff-fnz
107e : 08              >            php         ;save flags
107f : d95b02          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
1082 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1084 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
1085 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
1087 : d95f02          >            cmp absflo,y    ;test flags
                       >            trap_ne
108a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
108c : c60c                     dec zpt
108e : 88                       dey
108f : 10e4                     bpl tora2
                        
1091 : e042                     cpx #$42
                                trap_ne     ;x altered during test
1093 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1095 : ba                       tsx
1096 : e0ff                     cpx #$ff
                                trap_ne     ;sp push/pop mismatch
1098 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
109a : ad0202          >            lda test_case   ;previous test
109d : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
109f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
10a1 : a910            >            lda #test_num   ;*** next tests' number
10a3 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                            if I_flag = 3
10a6 : 58                       cli
                            endif                
                        
                        ; full binary add/subtract test - (zp) only
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
10a7 : d8                       cld
10a8 : a20e                     ldx #ad2        ;for indexed test
10aa : a0ff                     ldy #$ff        ;max range
10ac : a900                     lda #0          ;start with adding zeroes & no carry
10ae : 850c                     sta adfc        ;carry in - for diag
10b0 : 850d                     sta ad1         ;operand 1 - accumulator
10b2 : 850e                     sta ad2         ;operand 2 - memory or immediate
10b4 : 8d0502                   sta ada2        ;non zp
10b7 : 850f                     sta adrl        ;expected result bits 0-7
10b9 : 8510                     sta adrh        ;expected result bit 8 (carry out)
10bb : a9ff                     lda #$ff        ;complemented operand 2 for subtract
10bd : 8512                     sta sb2
10bf : 8d0602                   sta sba2        ;non zp
10c2 : a902                     lda #2          ;expected Z-flag
10c4 : 8511                     sta adrf
10c6 : 18               tadd    clc             ;test with carry clear
10c7 : 203d13                   jsr chkadd
10ca : e60c                     inc adfc        ;now with carry
10cc : e60f                     inc adrl        ;result +1
10ce : 08                       php             ;save N & Z from low result
10cf : 08                       php
10d0 : 68                       pla             ;accu holds expected flags
10d1 : 2982                     and #$82        ;mask N & Z
10d3 : 28                       plp
10d4 : d002                     bne tadd1
10d6 : e610                     inc adrh        ;result bit 8 - carry
10d8 : 0510             tadd1   ora adrh        ;merge C to expected flags
10da : 8511                     sta adrf        ;save expected flags except overflow
10dc : 38                       sec             ;test with carry set
10dd : 203d13                   jsr chkadd
10e0 : c60c                     dec adfc        ;same for operand +1 but no carry
10e2 : e60d                     inc ad1
10e4 : d0e0                     bne tadd        ;iterate op1
10e6 : a900                     lda #0          ;preset result to op2 when op1 = 0
10e8 : 8510                     sta adrh
10ea : ee0502                   inc ada2
10ed : e60e                     inc ad2
10ef : 08                       php             ;save NZ as operand 2 becomes the new result
10f0 : 68                       pla
10f1 : 2982                     and #$82        ;mask N00000Z0
10f3 : 8511                     sta adrf        ;no need to check carry as we are adding to 0
10f5 : c612                     dec sb2         ;complement subtract operand 2
10f7 : ce0602                   dec sba2
10fa : a50e                     lda ad2         
10fc : 850f                     sta adrl
10fe : d0c6                     bne tadd        ;iterate op2
                        
1100 : e00e                     cpx #ad2
                                trap_ne         ;x altered during test
1102 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1104 : c0ff                     cpy #$ff
                                trap_ne         ;y altered during test 
1106 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1108 : ba                       tsx
1109 : e0ff                     cpx #$ff
                                trap_ne         ;sp push/pop mismatch
110b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
110d : ad0202          >            lda test_case   ;previous test
1110 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1112 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
1114 : a911            >            lda #test_num   ;*** next tests' number
1116 : 8d0202          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, the V flag is ignored
                        ;   although V is declared as beeing valid on the 65C02 it has absolutely
                        ;   no use in BCD math. No sign = no overflow!
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
1119 : f8                       sed 
111a : a20e                     ldx #ad2        ;for indexed test
111c : a0ff                     ldy #$ff        ;max range
111e : a999                     lda #$99        ;start with adding 99 to 99 with carry
1120 : 850d                     sta ad1         ;operand 1 - accumulator
1122 : 850e                     sta ad2         ;operand 2 - memory or immediate
1124 : 8d0502                   sta ada2        ;non zp
1127 : 850f                     sta adrl        ;expected result bits 0-7
1129 : a901                     lda #1          ;set carry in & out
112b : 850c                     sta adfc        ;carry in - for diag
112d : 8510                     sta adrh        ;expected result bit 8 (carry out)
112f : a981                     lda #$81        ;set N & C (99 + 99 + C = 99 + C)
1131 : 8511                     sta adrf
1133 : a900                     lda #0          ;complemented operand 2 for subtract
1135 : 8512                     sta sb2
1137 : 8d0602                   sta sba2        ;non zp
113a : 38               tdad    sec             ;test with carry set
113b : 20e611                   jsr chkdad
113e : c60c                     dec adfc        ;now with carry clear
1140 : a50f                     lda adrl        ;decimal adjust result
1142 : d008                     bne tdad1       ;skip clear carry & preset result 99 (9A-1)
1144 : c610                     dec adrh
1146 : a999                     lda #$99
1148 : 850f                     sta adrl
114a : d012                     bne tdad3
114c : 290f             tdad1   and #$f         ;lower nibble mask
114e : d00c                     bne tdad2       ;no decimal adjust needed
1150 : c60f                     dec adrl        ;decimal adjust (?0-6)
1152 : c60f                     dec adrl
1154 : c60f                     dec adrl
1156 : c60f                     dec adrl
1158 : c60f                     dec adrl
115a : c60f                     dec adrl
115c : c60f             tdad2   dec adrl        ;result -1
115e : 08               tdad3   php             ;save valid flags
115f : 68                       pla
1160 : 2982                     and #$82        ;N-----Z-
1162 : 0510                     ora adrh        ;N-----ZC
1164 : 8511                     sta adrf
1166 : 18                       clc             ;test with carry clear
1167 : 20e611                   jsr chkdad
116a : e60c                     inc adfc        ;same for operand -1 but with carry
116c : a50d                     lda ad1         ;decimal adjust operand 1
116e : f015                     beq tdad5       ;iterate operand 2
1170 : 290f                     and #$f         ;lower nibble mask
1172 : d00c                     bne tdad4       ;skip decimal adjust
1174 : c60d                     dec ad1         ;decimal adjust (?0-6)
1176 : c60d                     dec ad1
1178 : c60d                     dec ad1
117a : c60d                     dec ad1
117c : c60d                     dec ad1
117e : c60d                     dec ad1
1180 : c60d             tdad4   dec ad1         ;operand 1 -1
1182 : 4c3a11                   jmp tdad        ;iterate op1
                        
1185 : a999             tdad5   lda #$99        ;precharge op1 max
1187 : 850d                     sta ad1
1189 : a50e                     lda ad2         ;decimal adjust operand 2
118b : f039                     beq tdad7       ;end of iteration
118d : 290f                     and #$f         ;lower nibble mask
118f : d018                     bne tdad6       ;skip decimal adjust
1191 : c60e                     dec ad2         ;decimal adjust (?0-6)
1193 : c60e                     dec ad2
1195 : c60e                     dec ad2
1197 : c60e                     dec ad2
1199 : c60e                     dec ad2
119b : c60e                     dec ad2
119d : e612                     inc sb2         ;complemented decimal adjust for subtract (?9+6)
119f : e612                     inc sb2
11a1 : e612                     inc sb2
11a3 : e612                     inc sb2
11a5 : e612                     inc sb2
11a7 : e612                     inc sb2
11a9 : c60e             tdad6   dec ad2         ;operand 2 -1
11ab : e612                     inc sb2         ;complemented operand for subtract
11ad : a512                     lda sb2
11af : 8d0602                   sta sba2        ;copy as non zp operand
11b2 : a50e                     lda ad2
11b4 : 8d0502                   sta ada2        ;copy as non zp operand
11b7 : 850f                     sta adrl        ;new result since op1+carry=00+carry +op2=op2
11b9 : 08                       php             ;save flags
11ba : 68                       pla
11bb : 2982                     and #$82        ;N-----Z-
11bd : 0901                     ora #1          ;N-----ZC
11bf : 8511                     sta adrf
11c1 : e610                     inc adrh        ;result carry
11c3 : 4c3a11                   jmp tdad        ;iterate op2
                        
11c6 : e00e             tdad7   cpx #ad2
                                trap_ne         ;x altered during test
11c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11ca : c0ff                     cpy #$ff
                                trap_ne         ;y altered during test 
11cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
11ce : ba                       tsx
11cf : e0ff                     cpx #$ff
                                trap_ne         ;sp push/pop mismatch
11d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11d3 : d8                       cld
                        
11d4 : ad0202                   lda test_case
11d7 : c911                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
11d9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11db : a9f0                     lda #$f0        ;mark opcode testing complete
11dd : 8d0202                   sta test_case
                        
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to 
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************       
                        ; -------------       
                                success         ;if you get here everything went well
11e0 : 4ce011          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************       
11e3 : 4c0004                   jmp start       ;run again      
                        
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, V flag is ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
11e6 :                  chkdad
                        ; decimal ADC / SBC zp
11e6 : 08                       php             ;save carry for subtract
11e7 : a50d                     lda ad1
11e9 : 650e                     adc ad2         ;perform add
11eb : 08                       php          
11ec : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
11ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
11f0 : 68                       pla             ;check flags
11f1 : 2983                     and #$83        ;mask N-----ZC
11f3 : c511                     cmp adrf
                                trap_ne         ;bad flags
11f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11f7 : 28                       plp
11f8 : 08                       php             ;save carry for next add
11f9 : a50d                     lda ad1
11fb : e512                     sbc sb2         ;perform subtract
11fd : 08                       php          
11fe : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
1200 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1202 : 68                       pla             ;check flags
1203 : 2983                     and #$83        ;mask N-----ZC
1205 : c511                     cmp adrf
                                trap_ne         ;bad flags
1207 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1209 : 28                       plp
                        ; decimal ADC / SBC abs
120a : 08                       php             ;save carry for subtract
120b : a50d                     lda ad1
120d : 6d0502                   adc ada2        ;perform add
1210 : 08                       php          
1211 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
1213 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1215 : 68                       pla             ;check flags
1216 : 2983                     and #$83        ;mask N-----ZC
1218 : c511                     cmp adrf
                                trap_ne         ;bad flags
121a : d0fe            >        bne *           ;failed not equal (non zero)
                        
121c : 28                       plp
121d : 08                       php             ;save carry for next add
121e : a50d                     lda ad1
1220 : ed0602                   sbc sba2        ;perform subtract
1223 : 08                       php          
1224 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
1226 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1228 : 68                       pla             ;check flags
1229 : 2983                     and #$83        ;mask N-----ZC
122b : c511                     cmp adrf
                                trap_ne         ;bad flags
122d : d0fe            >        bne *           ;failed not equal (non zero)
                        
122f : 28                       plp
                        ; decimal ADC / SBC #
1230 : 08                       php             ;save carry for subtract
1231 : a50e                     lda ad2
1233 : 8d0b02                   sta ex_adci+1   ;set ADC # operand
1236 : a50d                     lda ad1
1238 : 200a02                   jsr ex_adci     ;execute ADC # in RAM
123b : 08                       php          
123c : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
123e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1240 : 68                       pla             ;check flags
1241 : 2983                     and #$83        ;mask N-----ZC
1243 : c511                     cmp adrf
                                trap_ne         ;bad flags
1245 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1247 : 28                       plp
1248 : 08                       php             ;save carry for next add
1249 : a512                     lda sb2
124b : 8d0e02                   sta ex_sbci+1   ;set SBC # operand
124e : a50d                     lda ad1
1250 : 200d02                   jsr ex_sbci     ;execute SBC # in RAM
1253 : 08                       php          
1254 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
1256 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1258 : 68                       pla             ;check flags
1259 : 2983                     and #$83        ;mask N-----ZC
125b : c511                     cmp adrf
                                trap_ne         ;bad flags
125d : d0fe            >        bne *           ;failed not equal (non zero)
                        
125f : 28                       plp
                        ; decimal ADC / SBC zp,x
1260 : 08                       php             ;save carry for subtract
1261 : a50d                     lda ad1
1263 : 7500                     adc 0,x         ;perform add
1265 : 08                       php          
1266 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
1268 : d0fe            >        bne *           ;failed not equal (non zero)
                        
126a : 68                       pla             ;check flags
126b : 2983                     and #$83        ;mask N-----ZC
126d : c511                     cmp adrf
                                trap_ne         ;bad flags
126f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1271 : 28                       plp
1272 : 08                       php             ;save carry for next add
1273 : a50d                     lda ad1
1275 : f504                     sbc sb2-ad2,x   ;perform subtract
1277 : 08                       php          
1278 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
127a : d0fe            >        bne *           ;failed not equal (non zero)
                        
127c : 68                       pla             ;check flags
127d : 2983                     and #$83        ;mask N-----ZC
127f : c511                     cmp adrf
                                trap_ne         ;bad flags
1281 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1283 : 28                       plp
                        ; decimal ADC / SBC abs,x
1284 : 08                       php             ;save carry for subtract
1285 : a50d                     lda ad1
1287 : 7df701                   adc ada2-ad2,x  ;perform add
128a : 08                       php          
128b : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
128d : d0fe            >        bne *           ;failed not equal (non zero)
                        
128f : 68                       pla             ;check flags
1290 : 2983                     and #$83        ;mask N-----ZC
1292 : c511                     cmp adrf
                                trap_ne         ;bad flags
1294 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1296 : 28                       plp
1297 : 08                       php             ;save carry for next add
1298 : a50d                     lda ad1
129a : fdf801                   sbc sba2-ad2,x  ;perform subtract
129d : 08                       php          
129e : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
12a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12a2 : 68                       pla             ;check flags
12a3 : 2983                     and #$83        ;mask N-----ZC
12a5 : c511                     cmp adrf
                                trap_ne         ;bad flags
12a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12a9 : 28                       plp
                        ; decimal ADC / SBC abs,y
12aa : 08                       php             ;save carry for subtract
12ab : a50d                     lda ad1
12ad : 790601                   adc ada2-$ff,y  ;perform add
12b0 : 08                       php          
12b1 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
12b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12b5 : 68                       pla             ;check flags
12b6 : 2983                     and #$83        ;mask N-----ZC
12b8 : c511                     cmp adrf
                                trap_ne         ;bad flags
12ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
12bc : 28                       plp
12bd : 08                       php             ;save carry for next add
12be : a50d                     lda ad1
12c0 : f90701                   sbc sba2-$ff,y  ;perform subtract
12c3 : 08                       php          
12c4 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
12c6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12c8 : 68                       pla             ;check flags
12c9 : 2983                     and #$83        ;mask N-----ZC
12cb : c511                     cmp adrf
                                trap_ne         ;bad flags
12cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
12cf : 28                       plp
                        ; decimal ADC / SBC (zp,x)
12d0 : 08                       php             ;save carry for subtract
12d1 : a50d                     lda ad1
12d3 : 6144                     adc (lo adi2-ad2,x) ;perform add
12d5 : 08                       php          
12d6 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
12d8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12da : 68                       pla             ;check flags
12db : 2983                     and #$83        ;mask N-----ZC
12dd : c511                     cmp adrf
                                trap_ne         ;bad flags
12df : d0fe            >        bne *           ;failed not equal (non zero)
                        
12e1 : 28                       plp
12e2 : 08                       php             ;save carry for next add
12e3 : a50d                     lda ad1
12e5 : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
12e7 : 08                       php          
12e8 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
12ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ec : 68                       pla             ;check flags
12ed : 2983                     and #$83        ;mask N-----ZC
12ef : c511                     cmp adrf
                                trap_ne         ;bad flags
12f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12f3 : 28                       plp
                        ; decimal ADC / SBC (abs),y
12f4 : 08                       php             ;save carry for subtract
12f5 : a50d                     lda ad1
12f7 : 7156                     adc (adiy2),y   ;perform add
12f9 : 08                       php          
12fa : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
12fc : d0fe            >        bne *           ;failed not equal (non zero)
                        
12fe : 68                       pla             ;check flags
12ff : 2983                     and #$83        ;mask N-----ZC
1301 : c511                     cmp adrf
                                trap_ne         ;bad flags
1303 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1305 : 28                       plp
1306 : 08                       php             ;save carry for next add
1307 : a50d                     lda ad1
1309 : f158                     sbc (sbiy2),y   ;perform subtract
130b : 08                       php          
130c : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
130e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1310 : 68                       pla             ;check flags
1311 : 2983                     and #$83        ;mask N-----ZC
1313 : c511                     cmp adrf
                                trap_ne         ;bad flags
1315 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1317 : 28                       plp
                        ; decimal ADC / SBC (zp)
1318 : 08                       php             ;save carry for subtract
1319 : a50d                     lda ad1
131b : 7252                     adc (adi2)      ;perform add
131d : 08                       php          
131e : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
1320 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1322 : 68                       pla             ;check flags
1323 : 2983                     and #$83        ;mask N-----ZC
1325 : c511                     cmp adrf
                                trap_ne         ;bad flags
1327 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1329 : 28                       plp
132a : 08                       php             ;save carry for next add
132b : a50d                     lda ad1
132d : f254                     sbc (sbi2)      ;perform subtract
132f : 08                       php          
1330 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
1332 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1334 : 68                       pla             ;check flags
1335 : 2983                     and #$83        ;mask N-----ZC
1337 : c511                     cmp adrf
                                trap_ne         ;bad flags
1339 : d0fe            >        bne *           ;failed not equal (non zero)
                        
133b : 28                       plp
133c : 60                       rts
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
133d : a511             chkadd  lda adrf        ;add V-flag if overflow
133f : 2983                     and #$83        ;keep N-----ZC / clear V
1341 : 48                       pha
1342 : a50d                     lda ad1         ;test sign unequal between operands
1344 : 450e                     eor ad2
1346 : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
1348 : a50d                     lda ad1         ;test sign equal between operands and result
134a : 450f                     eor adrl
134c : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
134e : 68                       pla
134f : 0940                     ora #$40        ;set V
1351 : 48                       pha
1352 : 68               ckad1   pla
1353 : 8511                     sta adrf        ;save expected flags
                        ; binary ADC / SBC (zp)
1355 : 08                       php             ;save carry for subtract
1356 : a50d                     lda ad1
1358 : 7252                     adc (adi2)      ;perform add
135a : 08                       php          
135b : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
135d : d0fe            >        bne *           ;failed not equal (non zero)
                        
135f : 68                       pla             ;check flags
1360 : 29c3                     and #$c3        ;mask NV----ZC
1362 : c511                     cmp adrf
                                trap_ne         ;bad flags
1364 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1366 : 28                       plp
1367 : 08                       php             ;save carry for next add
1368 : a50d                     lda ad1
136a : f254                     sbc (sbi2)      ;perform subtract
136c : 08                       php          
136d : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
136f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1371 : 68                       pla             ;check flags
1372 : 29c3                     and #$c3        ;mask NV----ZC
1374 : c511                     cmp adrf
                                trap_ne         ;bad flags
1376 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1378 : 28                       plp
1379 : 60                       rts
                                
                        ; target for the jump indirect test
137a : 8013             ji_adr  dw test_ji
137c : 3e07                     dw ji_ret
                        
137e : 88                       dey
137f : 88                       dey
1380 :                  test_ji
1380 : 08                       php             ;either SP or Y count will fail, if we do not hit
1381 : 88                       dey
1382 : 88                       dey
1383 : 88                       dey
1384 : 28                       plp
                                trap_cs         ;flags loaded?
1385 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
1387 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
1389 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
138b : f0fe            >        beq *           ;failed equal (zero)
                        
138d : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
138f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1391 : e04e                     cpx #'N'
                                trap_ne        
1393 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1395 : c041                     cpy #('D'-3)
                                trap_ne
1397 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1399 : 48                       pha             ;save a,x
139a : 8a                       txa
139b : 48                       pha
139c : ba                       tsx
139d : e0fd                     cpx #$fd        ;check SP
                                trap_ne
139f : d0fe            >        bne *           ;failed not equal (non zero)
                        
13a1 : 68                       pla             ;restore x
13a2 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
13a3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13a5 : 48              >            pha         ;use stack to load status
13a6 : 28              >            plp
                        
13a7 : 68                       pla             ;restore a
13a8 : e8                       inx             ;return registers with modifications
13a9 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
13ab : 6cff02                   jmp (ji_tab+2)
13ae : ea                       nop
13af : ea                       nop
                                trap            ;runover protection
13b0 : 4cb013          >        jmp *           ;failed anyway
                        
13b3 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump indirect test
13b6 : fd13             jxi_adr dw  trap_ind
13b8 : fd13                     dw  trap_ind
13ba : c413                     dw  test_jxi    ;+4
13bc : 8a07                     dw  jxi_ret     ;+6
13be : fd13                     dw  trap_ind
13c0 : fd13                     dw  trap_ind
                        
13c2 : 88                       dey
13c3 : 88                       dey
13c4 :                  test_jxi
13c4 : 08                       php             ;either SP or Y count will fail, if we do not hit
13c5 : 88                       dey
13c6 : 88                       dey
13c7 : 88                       dey
13c8 : 28                       plp
                                trap_cs         ;flags loaded?
13c9 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
13cb : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
13cd : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
13cf : f0fe            >        beq *           ;failed equal (zero)
                        
13d1 : c958                     cmp #'X'        ;registers loaded?
                                trap_ne
13d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13d5 : e004                     cpx #4
                                trap_ne        
13d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13d9 : c046                     cpy #('I'-3)
                                trap_ne
13db : d0fe            >        bne *           ;failed not equal (non zero)
                        
13dd : 48                       pha             ;save a,x
13de : 8a                       txa
13df : 48                       pha
13e0 : ba                       tsx
13e1 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
13e3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13e5 : 68                       pla             ;restore x
13e6 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
13e7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13e9 : 48              >            pha         ;use stack to load status
13ea : 28              >            plp
                        
13eb : 68                       pla             ;restore a
13ec : e8                       inx             ;return registers with modifications
13ed : e8                       inx
13ee : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
13f0 : 7cf902                   jmp (jxi_tab,x)
13f3 : ea                       nop
13f4 : ea                       nop
                                trap            ;runover protection
13f5 : 4cf513          >        jmp *           ;failed anyway
                        
13f8 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                        ; JMP (abs,x) with bad x
13fb : ea                       nop
13fc : ea                       nop
13fd :                  trap_ind
13fd : ea                       nop
13fe : ea                       nop
                                trap            ;near miss indexed indirect jump
13ff : 4cff13          >        jmp *           ;failed anyway
                        
1402 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET
1405 :                  nmi_trap
                                trap            ;check stack for conditions at NMI
1405 : 4c0514          >        jmp *           ;failed anyway
                        
1408 : 4c0004                   jmp start       ;catastrophic error - cannot continue
140b :                  res_trap
                                trap            ;unexpected RESET
140b : 4c0b14          >        jmp *           ;failed anyway
                        
140e : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
1411 : 88                       dey
1412 : 88                       dey
1413 :                  irq_trap                ;BRK test or unextpected BRK or IRQ
1413 : 08                       php             ;either SP or Y count will fail, if we do not hit
1414 : 88                       dey
1415 : 88                       dey
1416 : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
1417 : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
1419 : f042                     beq break2
141b : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
141d : d0fe            >        bne *           ;failed not equal (non zero)
                        
141f : e052                     cpx #'R'
                                trap_ne        
1421 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1423 : c048                     cpy #'K'-3
                                trap_ne
1425 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1427 : 850a                     sta irq_a       ;save registers during break test
1429 : 860b                     stx irq_x
142b : ba                       tsx             ;test break on stack
142c : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
142f : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ;possible no break flag on stack
1431 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1433 : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
1434 : c934            >            cmp #(intdis |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
1436 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1438 : ba                       tsx
1439 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
143b : d0fe            >        bne *           ;failed not equal (non zero)
                        
143d : adff01                   lda $1ff        ;propper return on stack
1440 : c907                     cmp #hi(brk_ret0)
                                trap_ne
1442 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1444 : adfe01                   lda $1fe
1447 : c9dc                     cmp #lo(brk_ret0)
                                trap_ne
1449 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag $ff
144b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
144d : 48                       pha
144e : a60b                     ldx irq_x
1450 : e8                       inx             ;return registers with modifications
1451 : a50a                     lda irq_a
1453 : 49aa                     eor #$aa
1455 : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
1456 : 40                       rti
                                trap            ;runover protection
1457 : 4c5714          >        jmp *           ;failed anyway
                        
145a : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
145d :                  break2                  ;BRK pass 2        
145d : e0ad                     cpx #$ff-'R'
                                trap_ne        
145f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1461 : c0b1                     cpy #$ff-'K'-3
                                trap_ne
1463 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1465 : 850a                     sta irq_a       ;save registers during break test
1467 : 860b                     stx irq_x
1469 : ba                       tsx             ;test break on stack
146a : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
146d : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ;possibly no break flag on stack
146f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1471 : 68                       pla
                                cmp_flag $ff-decmode ;actual passed flags should have decmode cleared
1472 : c9f7            >            cmp #($ff-decmode |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
1474 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1476 : ba                       tsx
1477 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
1479 : d0fe            >        bne *           ;failed not equal (non zero)
                        
147b : adff01                   lda $1ff        ;propper return on stack
147e : c908                     cmp #hi(brk_ret1)
                                trap_ne
1480 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1482 : adfe01                   lda $1fe
1485 : c902                     cmp #lo(brk_ret1)
                                trap_ne
1487 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag intdis
1489 : a904            >            lda #intdis             ;allow test to change I-flag (no mask)
                        
148b : 48                       pha      
148c : a60b                     ldx irq_x
148e : e8                       inx             ;return registers with modifications
148f : a50a                     lda irq_a
1491 : 49aa                     eor #$aa
1493 : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
1494 : 40                       rti
                                trap            ;runover protection
1495 : 4c9514          >        jmp *           ;failed anyway
                        
1498 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
                            if report = 1
                                include "report.i65"
                            endif
                                    
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
                        data_init
                        ex_adc_ adc #0              ;execute immediate opcodes
                                rts
                        ex_sbc_ sbc #0              ;execute immediate opcodes
                                rts
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
                        rASL_                       ;expected result ASL & ROL -carry  
                        rROL_   db  $86,$04,$82,0   ; "
                        rROLc_  db  $87,$05,$83,1   ;expected result ROL +carry
                        rLSR_                       ;expected result LSR & ROR -carry
                        rROR_   db  $61,$41,$20,0   ; "
                        rRORc_  db  $e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                       ;expected flags for shifts
                        fROL_   db  fnc,fc,fn,fz    ;no carry in
                        fROLc_  db  fnc,fc,fn,0     ;carry in
                        fLSR_
                        fROR_   db  fc,0,fc,fz      ;no carry in
                        fRORc_  db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80   ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80 ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0     ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                        ; code at end of image due to the need to add blank space as required
                            if ($ff & (ji_ret - * - 2)) < ($ff & (jxi_ret - * - 2))
                        ; JMP (abs) when $xxff and $xx00 are from same page
149b : 00000000000000..         ds  lo(ji_ret - * - 2)
153c : ea                       nop
153d : ea                       nop
153e : ea               ji_px   nop             ;low address byte matched with ji_ret 
153f : ea                       nop
                                trap            ;jmp indirect page cross bug
1540 : 4c4015          >        jmp *           ;failed anyway
                        
                        
                        ; JMP (abs,x) when $xxff and $xx00 are from same page
1543 : 00000000000000..         ds  lo(jxi_ret - * - 2)
1588 : ea                       nop
1589 : ea                       nop
158a : ea               jxi_px  nop             ;low address byte matched with jxi_ret 
158b : ea                       nop
                                trap            ;jmp indexed indirect page cross bug
158c : 4c8c15          >        jmp *           ;failed anyway
                        
                            else
                        ; JMP (abs,x) when $xxff and $xx00 are from same page
                                ds  lo(jxi_ret - * - 2)
                                nop
                                nop
                        jxi_px  nop             ;low address byte matched with jxi_ret 
                                nop
                                trap            ;jmp indexed indirect page cross bug
                        
                        ; JMP (abs) when $xxff and $xx00 are from same page
                                ds  lo(ji_ret - * - 2)
                                nop
                                nop
                        ji_px   nop             ;low address byte matched with ji_ret 
                                nop
                                trap            ;jmp indirect page cross bug
                            endif
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
fffa =                          org $fffa       ;vectors
fffa : 0514                     dw  nmi_trap
fffc : 0b14                     dw  res_trap
fffe : 1314                     dw  irq_trap
                            endif
                        
fffa =                          end start
                        
No errors in pass 2.
